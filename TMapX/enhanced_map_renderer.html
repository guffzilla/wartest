<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎨 Enhanced Warcraft II Map Renderer - Texture-Based</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin: 0;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
            margin: 10px 0;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-group h3 {
            margin: 0 0 10px 0;
            color: #FFD700;
        }

        .btn {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #333;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .file-input {
            display: none;
        }

        .file-label {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            display: inline-block;
            transition: all 0.3s ease;
        }

        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }

        .map-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .map-visualization {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #FFD700;
        }

        .map-canvas {
            border: 2px solid #333;
            background: #333;
            display: block;
            margin: 0 auto;
            max-width: 100%;
        }

        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #FFD700;
        }

        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            color: white;
            z-index: 1000;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        
        .zoom-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .zoom-value {
            font-size: 18px;
            font-weight: bold;
            color: #4ECDC4;
        }
        
        .zoom-level {
            font-size: 12px;
            opacity: 0.8;
            color: #FFD700;
        }
        
        .zoom-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            justify-content: center;
        }
        
        .zoom-btn {
            background: #2C3E50;
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
        }
        
        .zoom-btn:hover {
            background: #34495E;
            transform: scale(1.1);
        }
        
        .zoom-btn:active {
            transform: scale(0.95);
        }
        
        .zoom-slider {
            width: 100%;
            margin-bottom: 8px;
        }
        
        .zoom-lod-info {
            font-size: 11px;
            text-align: center;
            opacity: 0.7;
            color: #87CEEB;
        }
        
        /* Tileset selector styling */
        #tilesetSelector {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        #tilesetSelector:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(65, 105, 225, 0.3);
        }
        
        #tilesetSelector:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(65, 105, 225, 0.5);
        }

        .texture-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .texture-info h4 {
            margin: 0 0 10px 0;
            color: #FFD700;
        }

        .texture-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 8px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #FFD700;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
        }

        .status.loading {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #FFC107;
            color: #FFC107;
        }

        .status.success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
            color: #4CAF50;
        }

        .status.error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #F44336;
            color: #F44336;
        }

        .overlay-controls {
            margin: 20px 0;
        }

        .overlay-toggle {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }

        .overlay-toggle input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }

        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1000;
            border: 2px solid #4169E1;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            min-width: 220px;
            max-width: 320px;
            backdrop-filter: blur(5px);
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        
        .tooltip.show {
            opacity: 1;
            transform: scale(1);
        }

        .tooltip-header {
            color: #FFD700;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .tooltip-content {
            line-height: 1.5;
        }
        
        .tooltip-marker {
            margin-top: 8px;
            padding: 8px;
            background: rgba(255, 215, 0, 0.1);
            border-left: 3px solid #FFD700;
            border-radius: 4px;
        }

        .tooltip-player {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(78, 205, 196, 0.1));
            border-left: 3px solid #FFD700;
            border-radius: 6px;
            padding: 10px;
            margin-top: 5px;
        }

        .tooltip-goldmine {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 193, 7, 0.1));
            border-left: 3px solid #FFD700;
            border-radius: 6px;
            padding: 10px;
            margin-top: 5px;
        }
        
        /* Enhanced marker hover effects */
        .marker-hover {
            animation: pulse 1.5s ease-in-out infinite alternate;
        }
        
        @keyframes pulse {
            from {
                transform: scale(1);
                opacity: 1;
            }
            to {
                transform: scale(1.05);
                opacity: 0.8;
            }
        }
        
        /* Goldmine sparkle animation */
        .goldmine-sparkle {
            animation: sparkle 2s ease-in-out infinite;
        }
        
        @keyframes sparkle {
            0%, 100% { opacity: 0.3; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1.2); }
        }
        
        /* Oil bubble animation */
        .oil-bubble {
            animation: bubble 3s ease-in-out infinite;
        }
        
        @keyframes bubble {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-2px) scale(1.1); }
        }
        
        /* Chess piece crown animation */
        .crown-jewel {
            animation: jewel-shine 4s ease-in-out infinite;
        }
        
        @keyframes jewel-shine {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            25% { opacity: 1; transform: scale(1.1); }
            50% { opacity: 0.9; transform: scale(1.05); }
            75% { opacity: 1; transform: scale(1.15); }
        }
        
        /* Goldmine texture animation */
        .goldmine-texture {
            animation: texture-rotate 8s linear infinite;
        }
        
        @keyframes texture-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Oil ripple animation */
        .oil-ripple {
            animation: ripple-expand 6s ease-out infinite;
        }
        
        @keyframes ripple-expand {
            0% { transform: scale(0.8); opacity: 0.8; }
            100% { transform: scale(1.2); opacity: 0; }
        }
        
        /* Status banner pulse animation */
        @keyframes statusPulse {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            }
            50% { 
                transform: scale(1.02); 
                box-shadow: 0 8px 30px rgba(0,0,0,0.5);
            }
        }

        @media (max-width: 1200px) {
            .map-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎨 Enhanced Warcraft II Map Renderer</h1>
            <p>Texture-Based Rendering with Authentic Warcraft II Visuals</p>
            <div id="graphicsStatus" style="background: linear-gradient(45deg, #FF6B6B, #4ECDC4, #45B7D1, #96CEB4, #FFEAA7); padding: 10px; border-radius: 8px; margin-top: 10px; text-align: center; color: white; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); animation: statusPulse 3s ease-in-out infinite;">
                ✨ SUPER ENHANCED GRAPHICS LOADED ✨<br>
                🎯 Chess Piece Players | 💎 Multi-Layer Goldmines | 🛢️ Bubbling Oil Patches
            </div>
            
            <div id="performanceMonitor" style="background: #2C3E50; color: #ECF0F1; padding: 8px; border-radius: 6px; margin-top: 10px; text-align: center; font-family: monospace; font-size: 12px;">
                <strong>Performance Monitor:</strong> FPS: <span id="fpsDisplay">--</span> | 
                Redraws: <span id="redrawCount">--</span> | 
                Status: <span id="performanceStatus">Monitoring...</span>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>📁 Map File</h3>
                <input type="file" id="mapFile" class="file-input" accept=".pud">
                <label for="mapFile" class="file-label">Choose PUD File</label>
            </div>

            <div class="control-group">
                <h3>🎨 Rendering Mode</h3>
                <button id="textureMode" class="btn">🖼️ Texture Mode</button>
                <button id="colorMode" class="btn">🎨 Color Mode</button>
                <button id="hybridMode" class="btn">🔄 Hybrid Mode</button>
            </div>

            <div class="control-group">
                <h3>⚙️ System</h3>
                <button id="extractTextures" class="btn">🔍 Extract Textures</button>
                <button id="clearCache" class="btn">🗑️ Clear Cache</button>
            </div>

            <div class="control-group">
                <h3>🎨 Tileset Selection</h3>
                <select id="tilesetSelector" class="btn" style="background: #4169E1;">
                    <option value="0">🌲 Forest</option>
                    <option value="1">❄️ Winter</option>
                    <option value="2">🏜️ Wasteland</option>
                    <option value="3">🌿 Swamp</option>
                </select>
            </div>
        </div>

        <div class="map-container">
            <div class="map-visualization">
                <canvas id="mapCanvas" class="map-canvas" width="800" height="600"></canvas>
                
                <div class="zoom-controls">
                    <div class="zoom-info">
                        <div class="zoom-value" id="zoomValue">8x</div>
                        <div class="zoom-level" id="zoomLevel">Level 8</div>
                    </div>
                    <div class="zoom-buttons">
                        <button id="zoomOut" class="zoom-btn" title="Zoom Out">➖</button>
                        <button id="zoomReset" class="zoom-btn" title="Reset Zoom">🔄</button>
                        <button id="zoomIn" class="zoom-btn" title="Zoom In">➕</button>
                    </div>
                    <input type="range" id="zoomSlider" class="zoom-slider" min="4" max="32" value="8" step="2">
                    <div class="zoom-lod-info" id="zoomLodInfo">LOD: Cached</div>
                </div>
            </div>

            <div class="sidebar">
                <div class="texture-info">
                    <h4>🎨 Texture System Status</h4>
                    <div class="texture-stats">
                        <div class="stat-item">
                            <div class="stat-value" id="textureStatus">❌</div>
                            <div class="stat-label">Status</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="cachedTextures">0</div>
                            <div class="stat-label">Cached</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalTextures">0</div>
                            <div class="stat-label">Total</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalSize">0 KB</div>
                            <div class="stat-label">Size</div>
                        </div>
                    </div>
                </div>

                <div class="texture-info">
                    <h4>🗺️ Map Information</h4>
                    <div class="texture-stats">
                        <div class="stat-item">
                            <div class="stat-value" id="mapTileset">-</div>
                            <div class="stat-label">Tileset</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="mapDimensions">-</div>
                            <div class="stat-label">Dimensions</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="mapMarkers">-</div>
                            <div class="stat-label">Markers</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="mapTerrain">-</div>
                            <div class="stat-label">Terrain</div>
                        </div>
                    </div>
                </div>

                <div class="overlay-controls">
                    <h4>🎯 Overlays</h4>
                    <div class="overlay-toggle">
                        <input type="checkbox" id="showResources" checked>
                        <label for="showResources">💰 Resources</label>
                    </div>
                    <div class="overlay-toggle">
                        <input type="checkbox" id="showUnits" checked>
                        <label for="showUnits">⚔️ Units</label>
                    </div>
                    <div class="overlay-toggle">
                        <input type="checkbox" id="showPlayers" checked>
                        <label for="showPlayers">👤 Players</label>
                    </div>
                </div>

                <div id="status" class="status"></div>
            </div>
        </div>
    </div>

    <div id="tooltip" class="tooltip" style="display: none;"></div>

    <script src="binary_parser_fixed.js"></script>
    <script type="module">
        import { TextureManager } from './texture_manager.js';

        let textureManager = null;
        let mapRenderer = null;
        let currentMapData = null;

        // Initialize the application
        async function initializeApp() {
            try {
                showStatus('Initializing system...', 'loading');
                
                // Check if FixedBinaryParser is loaded
                if (typeof FixedBinaryParser === 'undefined') {
                    throw new Error('FixedBinaryParser not loaded! Check if binary_parser_fixed.js is accessible.');
                }
                console.log('✅ FixedBinaryParser loaded successfully:', FixedBinaryParser);
                
                // Initialize texture manager (no WASM needed)
                textureManager = new TextureManager();
                await textureManager.initializeWithoutWasm();
                
                // Initialize map renderer
                mapRenderer = new EnhancedMapRenderer('mapCanvas', textureManager);
                
                showStatus('System ready!', 'success');
                updateTextureStats();
                
                // Set up event listeners
                setupEventListeners();
                
                // Start performance monitoring
                setInterval(updatePerformanceMonitor, 1000);
                
            } catch (error) {
                console.error('❌ Initialization failed:', error);
                showStatus('Initialization failed: ' + error.message, 'error');
            }
        }

        // Enhanced Map Renderer Class
        class EnhancedMapRenderer {
            constructor(canvasId, textureManager) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.textureManager = textureManager;
                this.zoomLevel = 8;
                this.tileSize = 12;
                this.overlays = {
                    resources: true,
                    units: true,
                    players: true
                };
                
                // Performance control flags
                this.isAnimating = false;
                this.animationFrameId = null;
                this.lastRedrawTime = 0;
                this.redrawThrottle = 16; // ~60fps max
                
                // Performance monitoring
                this.frameCount = 0;
                this.lastFpsTime = performance.now();
                this.fps = 0;
                
                // Animation batching for performance
                this.pendingAnimations = new Set();
                this.animationBatchId = null;
                
                // LAYERED CANVASES - HIGHEST IMPACT CHANGE
                this.setupLayeredCanvases();
                
                // Pre-rendered markers cache
                this.markerCache = new Map();
                this.markerScales = [0.5, 1.0, 2.0, 4.0]; // Common zoom levels
                
                // ZOOM CACHING + LOD SYSTEM
                this.zoomCache = new Map(); // Cache terrain at different zoom levels
                this.zoomLevels = [4, 6, 8, 12, 16, 24, 32]; // Supported zoom levels
                this.currentZoomIndex = 3; // Start at zoom level 8
                this.zoomDebounceTimer = null;
                this.isZooming = false;
                
                this.setupCanvas();
            }

            setupCanvas() {
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseleave', this.hideTooltip.bind(this));
                
                // Canvas performance optimizations
                this.ctx.imageSmoothingEnabled = false; // Disable anti-aliasing for better performance
                this.ctx.imageSmoothingQuality = 'low'; // Use low quality for speed
                
                // Enable hardware acceleration hints
                this.canvas.style.willChange = 'transform';
                this.canvas.style.transform = 'translateZ(0)';
            }
            
            setupLayeredCanvases() {
                // Create separate canvases for each layer - HIGHEST IMPACT
                this.terrainCanvas = document.createElement('canvas');
                this.markersCanvas = document.createElement('canvas');
                this.fxCanvas = document.createElement('canvas');
                this.uiCanvas = document.createElement('canvas');
                
                // Get contexts for each layer
                this.terrainCtx = this.terrainCanvas.getContext('2d');
                this.markersCtx = this.markersCanvas.getContext('2d');
                this.fxCtx = this.fxCanvas.getContext('2d');
                this.uiCtx = this.uiCanvas.getContext('2d');
                
                // Optimize all contexts
                [this.terrainCtx, this.markersCtx, this.fxCtx, this.uiCtx].forEach(ctx => {
                    ctx.imageSmoothingEnabled = false;
                    ctx.imageSmoothingQuality = 'low';
                });
                
                // Set initial sizes
                this.resizeLayeredCanvases();
                
                console.log('🎨 Layered canvases created for terrain, markers, FX, and UI');
            }
            
            resizeLayeredCanvases() {
                const displaySize = this.tileSize * this.zoomLevel;
                const width = currentMapData ? currentMapData.width * displaySize : 800;
                const height = currentMapData ? currentMapData.height * displaySize : 600;
                
                [this.terrainCanvas, this.markersCanvas, this.fxCanvas, this.uiCanvas].forEach(canvas => {
                    canvas.width = width;
                    canvas.height = height;
                });
                
                console.log(`📏 Layered canvases resized to ${width}x${height}`);
            }

            setZoom(level) {
                // DEBOUNCED ZOOM with LOD support
                if (this.zoomDebounceTimer) {
                    clearTimeout(this.zoomDebounceTimer);
                }
                
                this.zoomDebounceTimer = setTimeout(() => {
                    this.performZoom(level);
                }, 100); // 100ms debounce for smooth zooming
            }
            
            performZoom(level) {
                console.log(`🔍 Zooming from ${this.zoomLevel} to ${level}`);
                
                // Find closest supported zoom level
                const targetIndex = this.findClosestZoomIndex(level);
                const targetZoom = this.zoomLevels[targetIndex];
                
                if (targetZoom === this.zoomLevel) {
                    console.log(`🔍 Already at zoom level ${targetZoom}`);
                    return;
                }
                
                this.isZooming = true;
                this.zoomLevel = targetZoom;
                this.currentZoomIndex = targetIndex;
                
                // Resize all layered canvases for new zoom
                this.resizeLayeredCanvases();
                
                // Check if we have cached terrain for this zoom level
                if (this.zoomCache.has(targetZoom)) {
                    console.log(`🔍 Using cached terrain for zoom ${targetZoom}`);
                    this.useCachedTerrain(targetZoom);
                } else {
                    console.log(`🔍 Rendering new terrain for zoom ${targetZoom}`);
                    this.cacheTerrainAtZoom(targetZoom);
                }
                
                // Update markers for new zoom level
                this.updateMarkersForZoom();
                
                // Composite all layers
                this.compositeLayers();
                
                this.isZooming = false;
                console.log(`✅ Zoom complete: ${targetZoom}`);
            }
            
            findClosestZoomIndex(targetZoom) {
                let closestIndex = 0;
                let closestDiff = Math.abs(this.zoomLevels[0] - targetZoom);
                
                for (let i = 1; i < this.zoomLevels.length; i++) {
                    const diff = Math.abs(this.zoomLevels[i] - targetZoom);
                    if (diff < closestDiff) {
                        closestDiff = diff;
                        closestIndex = i;
                    }
                }
                
                return closestIndex;
            }
            
            cacheTerrainAtZoom(zoomLevel) {
                if (!currentMapData || !currentMapData.terrain_runs) return;
                
                console.log(`🎨 Caching terrain at zoom level ${zoomLevel}`);
                
                // Create temporary canvas for this zoom level
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                const displaySize = this.tileSize * zoomLevel;
                const width = currentMapData.width * displaySize;
                const height = currentMapData.height * displaySize;
                
                tempCanvas.width = width;
                tempCanvas.height = height;
                
                // Render terrain at this zoom level
                this.renderTerrain(displaySize, tempCtx);
                
                // Cache the rendered terrain
                this.zoomCache.set(zoomLevel, tempCanvas);
                
                console.log(`✅ Terrain cached for zoom ${zoomLevel} (${width}x${height})`);
            }
            
            useCachedTerrain(zoomLevel) {
                const cachedTerrain = this.zoomCache.get(zoomLevel);
                if (!cachedTerrain) return;
                
                // Copy cached terrain to terrain layer
                const ctx = this.terrainCtx;
                ctx.clearRect(0, 0, this.terrainCanvas.width, this.terrainCanvas.height);
                ctx.drawImage(cachedTerrain, 0, 0);
                
                console.log(`🎨 Using cached terrain for zoom ${zoomLevel}`);
            }
            
            updateMarkersForZoom() {
                // Update marker cache for new zoom level
                const displaySize = this.tileSize * this.zoomLevel;
                const scale = this.getMarkerScale(displaySize);
                
                console.log(`🎨 Updating markers for zoom ${this.zoomLevel}, scale ${scale}`);
                
                // Re-render markers layer with new scale
                this.renderMarkersLayer();
                
                // Update zoom UI display
                this.updateZoomUI();
            }
            
            updateZoomUI() {
                // Update zoom display elements
                const zoomValue = document.getElementById('zoomValue');
                const zoomLevel = document.getElementById('zoomLevel');
                const zoomLodInfo = document.getElementById('zoomLodInfo');
                
                if (zoomValue) zoomValue.textContent = this.zoomLevel + 'x';
                if (zoomLevel) zoomLevel.textContent = `Level ${this.zoomLevel}`;
                
                // Show LOD status
                if (zoomLodInfo) {
                    if (this.zoomCache.has(this.zoomLevel)) {
                        zoomLodInfo.textContent = 'LOD: Cached';
                        zoomLodInfo.style.color = '#4CAF50'; // Green for cached
                    } else {
                        zoomLodInfo.textContent = 'LOD: Rendering...';
                        zoomLodInfo.style.color = '#FF9800'; // Orange for rendering
                    }
                }
                
                // Update zoom slider
                const zoomSlider = document.getElementById('zoomSlider');
                if (zoomSlider) {
                    zoomSlider.value = this.zoomLevel;
                }
            }

            setOverlays(overlays) {
                this.overlays = { ...this.overlays, ...overlays };
                // Only redraw overlays, not the entire map
                this.redrawOverlays();
            }
            
            redrawOverlays() {
                if (!currentMapData) return;
                
                // Just redraw the entire map to ensure overlays are visible
                console.log('🎨 Redrawing entire map to ensure overlays are visible');
                this.redraw();
            }

            async renderMap(mapData) {
                currentMapData = mapData;
                
                // Initialize zoom system for new map
                this.initializeZoomSystem();
                
                // Resize layered canvases for new map
                this.resizeLayeredCanvases();
                
                // Pre-render all markers at different scales - HIGH IMPACT
                await this.preRenderMarkers();
                
                // Render terrain once (static) at current zoom
                this.renderTerrainLayer();
                
                // Start animations
                this.startAnimations();
                
                // Composite all layers
                this.compositeLayers();
                
                // Update zoom UI
                this.updateZoomUI();
            }
            
            initializeZoomSystem() {
                // Clear previous zoom cache
                this.zoomCache.clear();
                
                // Cache terrain at current zoom level
                this.cacheTerrainAtZoom(this.zoomLevel);
                
                console.log(`🔍 Zoom system initialized for map ${currentMapData.width}x${currentMapData.height}`);
            }
            
            startAnimations() {
                this.isAnimating = true;
                
                // Start batched animation system
                this.startBatchedAnimations();
            }
            
            startBatchedAnimations() {
                if (this.animationBatchId) return;
                
                // EVENT-DRIVEN RAF - Only animate when needed
                this.animationBatchId = requestAnimationFrame(() => this.processAnimations());
            }
            
            processAnimations() {
                if (!this.isAnimating || this.pendingAnimations.size === 0) {
                    this.animationBatchId = null;
                    return;
                }
                
                // Process all pending animations
                this.pendingAnimations.forEach(marker => {
                    if (marker.isAnimating) {
                        this.updateMarkerAnimation(marker);
                    }
                });
                
                // Only update FX layer - NO FULL REDRAW
                this.updateFXLayer();
                
                // 30 FPS FX CAP for performance - continue only if needed
                if (this.pendingAnimations.size > 0) {
                    // Cap at 30fps for FX updates (33ms intervals)
                    setTimeout(() => {
                        if (this.isAnimating) {
                            this.animationBatchId = requestAnimationFrame(() => this.processAnimations());
                        }
                    }, 33);
                } else {
                    this.animationBatchId = null;
                }
            }
            
            updateMarkerAnimation(marker) {
                const elapsed = Date.now() - marker.animationStartTime;
                const animationDuration = 2000; // 2 seconds
                const progress = (elapsed % animationDuration) / animationDuration;
                
                // Update animation properties with FULL VISUAL IMPACT
                marker.animationProgress = progress;
                marker.animationAngle = progress * Math.PI * 2;
                marker.animationScale = 1 + Math.sin(progress * Math.PI * 4) * 0.1;
                marker.animationRotation = progress * Math.PI * 0.5;
                marker.animationGlow = 0.8 + Math.sin(progress * Math.PI * 3) * 0.2;
            }
            
            async preRenderMarkers() {
                console.log('🎨 Pre-rendering markers at multiple scales...');
                
                // Clear marker cache
                this.markerCache.clear();
                
                if (!currentMapData || !currentMapData.markers) return;
                
                // Pre-render each marker type at different scales
                for (const scale of this.markerScales) {
                    for (const marker of currentMapData.markers) {
                        const cacheKey = `${marker.marker_type}_${marker.player || 'neutral'}_${scale}`;
                        
                        if (!this.markerCache.has(cacheKey)) {
                            const markerCanvas = document.createElement('canvas');
                            const markerCtx = markerCanvas.getContext('2d');
                            
                            // Set size based on scale
                            const baseSize = 60; // Base marker size
                            const scaledSize = baseSize * scale;
                            markerCanvas.width = scaledSize * 2; // Extra space for glow effects
                            markerCanvas.height = scaledSize * 2;
                            
                            // Center the marker
                            markerCtx.translate(scaledSize, scaledSize);
                            
                            // Render marker based on type
                            if (marker.marker_type === 'player') {
                                this.renderPlayerMarker(markerCtx, scaledSize, marker, false);
                            } else if (marker.marker_type === 'goldmine') {
                                this.renderGoldmineMarker(markerCtx, scaledSize, marker, false);
                            } else if (marker.marker_type === 'oil') {
                                this.renderOilMarker(markerCtx, scaledSize, marker, false);
                            }
                            
                            // Convert to ImageBitmap for GPU acceleration
                            try {
                                const imageBitmap = await createImageBitmap(markerCanvas);
                                this.markerCache.set(cacheKey, imageBitmap);
                                console.log(`✅ Pre-rendered ${cacheKey}`);
                            } catch (error) {
                                console.warn(`⚠️ Failed to create ImageBitmap for ${cacheKey}:`, error);
                                // Fallback to canvas
                                this.markerCache.set(cacheKey, markerCanvas);
                            }
                        }
                    }
                }
                
                console.log(`🎨 Pre-rendered ${this.markerCache.size} marker variants`);
            }
            
            stopAnimations() {
                this.isAnimating = false;
                
                // Stop individual marker animations
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                
                // Stop batched animations
                if (this.animationBatchId) {
                    cancelAnimationFrame(this.animationBatchId);
                    this.animationBatchId = null;
                }
                
                // Clear pending animations
                this.pendingAnimations.clear();
            }

            redraw() {
                if (!currentMapData) return;
                
                // FPS monitoring
                const now = performance.now();
                this.frameCount++;
                if (now - this.lastFpsTime >= 1000) { // Update FPS every second
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsTime = now;
                    
                    // Log performance warnings
                    if (this.fps < 30) {
                        console.warn(`⚠️ Performance Warning: Low FPS detected: ${this.fps}`);
                    }
                }
                
                const displaySize = this.tileSize * this.zoomLevel;
                const newWidth = currentMapData.width * displaySize;
                const newHeight = currentMapData.height * displaySize;
                
                // Only resize canvas if dimensions actually changed
                if (this.canvas.width !== newWidth || this.canvas.height !== newHeight) {
                    this.canvas.width = newWidth;
                    this.canvas.height = newHeight;
                }
                
                // Performance optimization: Batch canvas operations
                this.ctx.save();
                
                // Clear canvas
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Render terrain
                this.renderTerrain(displaySize);
                
                // ALWAYS render overlays after terrain - don't check overlay settings here
                // This ensures overlays are always drawn and visible
                console.log('🎨 Rendering ALL overlays after terrain');
                this.renderResources(displaySize);
                this.renderUnits(displaySize);
                this.renderPlayers(displaySize);
                
                // Restore canvas context
                this.ctx.restore();
            }
            
            renderTerrainLayer() {
                // Render terrain ONCE to terrain canvas (static)
                if (!currentMapData || !currentMapData.terrain_runs) return;
                
                const displaySize = this.tileSize * this.zoomLevel;
                const ctx = this.terrainCtx;
                
                // Clear terrain layer
                ctx.clearRect(0, 0, this.terrainCanvas.width, this.terrainCanvas.height);
                
                // Render terrain using existing logic
                this.renderTerrain(displaySize, ctx);
                
                console.log('🎨 Terrain layer rendered (static)');
            }
            
            renderMarkersLayer() {
                // Render markers ONCE to markers canvas (static)
                if (!currentMapData || !currentMapData.markers) return;
                
                const displaySize = this.tileSize * this.zoomLevel;
                const ctx = this.markersCtx;
                
                // Clear markers layer
                ctx.clearRect(0, 0, this.markersCanvas.width, this.markersCanvas.height);
                
                // Render markers using pre-rendered cache
                this.renderMarkersFromCache(displaySize, ctx);
                
                console.log('🎨 Markers layer rendered (static)');
            }
            
            updateFXLayer() {
                // Update only FX layer (animations, hover effects)
                if (!currentMapData || !currentMapData.markers) return;
                
                const ctx = this.fxCtx;
                
                // Clear FX layer
                ctx.clearRect(0, 0, this.fxCanvas.width, this.fxCanvas.height);
                
                // Render only animated/hover effects
                this.renderFXEffects(ctx);
                
                // Composite FX layer to main canvas
                this.compositeFXLayer();
            }
            
            compositeLayers() {
                // Composite all layers to main canvas
                const ctx = this.ctx;
                
                // Clear main canvas
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw terrain layer (static)
                ctx.drawImage(this.terrainCanvas, 0, 0);
                
                // Draw markers layer (static)
                ctx.drawImage(this.markersCanvas, 0, 0);
                
                // Draw FX layer (dynamic)
                ctx.drawImage(this.fxCanvas, 0, 0);
                
                // Draw UI layer (if any)
                ctx.drawImage(this.uiCanvas, 0, 0);
                
                console.log('🎨 All layers composited to main canvas');
            }
            
            renderMarkersFromCache(displaySize, ctx) {
                // Render markers using pre-rendered cache
                if (!currentMapData || !currentMapData.markers) return;
                
                for (const marker of currentMapData.markers) {
                    const x = marker.x * displaySize;
                    const y = marker.y * displaySize;
                    
                    // Find appropriate cached marker
                    const scale = this.getMarkerScale(displaySize);
                    const cacheKey = `${marker.marker_type}_${marker.player || 'neutral'}_${scale}`;
                    const cachedMarker = this.markerCache.get(cacheKey);
                    
                    if (cachedMarker) {
                        // Draw pre-rendered marker
                        const markerSize = 60 * scale;
                        ctx.drawImage(cachedMarker, 
                            x + displaySize/2 - markerSize, 
                            y + displaySize/2 - markerSize,
                            markerSize * 2, markerSize * 2);
                    } else {
                        // Fallback to direct rendering
                        if (marker.marker_type === 'player') {
                            this.renderPlayerMarker(ctx, 60, marker, false);
                        } else if (marker.marker_type === 'goldmine') {
                            this.renderGoldmineMarker(ctx, 60, marker, false);
                        } else if (marker.marker_type === 'oil') {
                            this.renderOilMarker(ctx, 60, marker, false);
                        }
                    }
                }
            }
            
            getMarkerScale(displaySize) {
                // Find appropriate scale for current zoom level
                const baseSize = 12; // Base tile size
                const currentScale = displaySize / baseSize;
                
                // Find closest pre-rendered scale
                let bestScale = this.markerScales[0];
                let bestDiff = Math.abs(currentScale - bestScale);
                
                for (const scale of this.markerScales) {
                    const diff = Math.abs(currentScale - scale);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        bestScale = scale;
                    }
                }
                
                return bestScale;
            }
            
            renderFXEffects(ctx) {
                // Render only animated/hover effects
                if (!currentMapData || !currentMapData.markers) return;
                
                for (const marker of currentMapData.markers) {
                    if (marker.isAnimating || marker === this.hoveredMarker) {
                        // Render enhanced effects for animated/hovered markers
                        const displaySize = this.tileSize * this.zoomLevel;
                        const x = marker.x * displaySize;
                        const y = marker.y * displaySize;
                        
                        if (marker.marker_type === 'player') {
                            this.renderPlayerMarker(ctx, 60, marker, true);
                        } else if (marker.marker_type === 'goldmine') {
                            this.renderGoldmineMarker(ctx, 60, marker, true);
                        } else if (marker.marker_type === 'oil') {
                            this.renderOilMarker(ctx, 60, marker, true);
                        }
                    }
                }
            }
            
            // Pre-rendering helper methods
            renderPlayerMarker(ctx, size, marker, enhanced = false) {
                // Simplified version for pre-rendering
                const centerX = 0; // Pre-rendered markers are centered
                const centerY = 0;
                
                // Basic chess piece shape
                ctx.fillStyle = enhanced ? '#FFD700' : '#8B4513';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size/2, 0, Math.PI * 2);
                ctx.fill();
                
                if (enhanced) {
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            renderGoldmineMarker(ctx, size, marker, enhanced = false) {
                // Simplified version for pre-rendering
                const centerX = 0;
                const centerY = 0;
                
                // Basic hexagonal shape
                ctx.fillStyle = enhanced ? '#FFD700' : '#B8860B';
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI) / 3;
                    const x = centerX + Math.cos(angle) * size/2;
                    const y = centerY + Math.sin(angle) * size/2;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                if (enhanced) {
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            renderOilMarker(ctx, size, marker, enhanced = false) {
                // Simplified version for pre-rendering
                const centerX = 0;
                const centerY = 0;
                
                // Basic octagonal shape
                ctx.fillStyle = enhanced ? '#1E90FF' : '#000080';
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI) / 4;
                    const x = centerX + Math.cos(angle) * size/2;
                    const y = centerY + Math.sin(angle) * size/2;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                if (enhanced) {
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            compositeFXLayer() {
                // Composite FX layer to main canvas (for animations)
                const ctx = this.ctx;
                ctx.drawImage(this.fxCanvas, 0, 0);
            }

            renderTerrain(displaySize, ctx = this.ctx) {
                if (!currentMapData.terrain_runs) return;
                
                // Create a 2D array to store terrain data
                const terrainGrid = [];
                for (let y = 0; y < currentMapData.height; y++) {
                    terrainGrid[y] = [];
                    for (let x = 0; x < currentMapData.width; x++) {
                        terrainGrid[y][x] = { tile_id: 0, terrain_type: 'grass' };
                    }
                }
                
                // Fill the terrain grid from runs
                let currentTile = 0;
                for (const run of currentMapData.terrain_runs) {
                    for (let i = 0; i < run.count; i++) {
                        const tileIndex = currentTile + i;
                        const x = tileIndex % currentMapData.width;
                        const y = Math.floor(tileIndex / currentMapData.width);
                        
                        if (y < currentMapData.height && x < currentMapData.width) {
                            terrainGrid[y][x] = {
                                tile_id: run.tile_id,
                                terrain_type: run.terrain_type
                            };
                        }
                    }
                    currentTile += run.count;
                }
                
                // Render the terrain grid
                for (let y = 0; y < currentMapData.height; y++) {
                    for (let x = 0; x < currentMapData.width; x++) {
                        const tile = terrainGrid[y][x];
                        const renderX = x * displaySize;
                        const renderY = y * displaySize;
                        
                        // Use texture manager to render tile with tileset support
                        this.textureManager.renderFallbackTileWithTerrainType(
                            ctx,
                            tile.terrain_type,
                            renderX,
                            renderY,
                            displaySize,
                            currentMapData.tileset
                        );
                    }
                }
                
                // Center indicator removed for performance optimization
            }
            
            // drawCenterIndicator method completely removed for performance optimization

            renderResources(displaySize) {
                console.log('🎨 renderResources called, markers:', currentMapData.markers);
                if (!currentMapData.markers) {
                    console.log('🎨 No markers found in currentMapData for resources');
                    return;
                }
                
                console.log(`🎨 Found ${currentMapData.markers.length} markers to check for resources`);
                for (const marker of currentMapData.markers) {
                    console.log('🎨 Checking marker for resources:', marker);
                    if (marker.marker_type === 'goldmine') {
                        const x = marker.x * displaySize;
                        const y = marker.y * displaySize;
                        
                        // Enhanced goldmine marker - SAME SIZE as players for consistency
                        const size = Math.max(displaySize * 5, 60); // Same as players
                        const centerX = x + displaySize/2;
                        const centerY = y + displaySize/2;
                        
                        this.ctx.save();
                        
                        // Check if this marker is being hovered over
                        const isHovered = this.hoveredMarker && 
                            this.hoveredMarker.x === marker.x && 
                            this.hoveredMarker.y === marker.y && 
                            this.hoveredMarker.marker_type === 'goldmine';
                        
                        // Advanced goldmine design - hexagonal mine entrance with depth
                        this.ctx.save();
                        
                        // Apply animation scaling if this marker is animating
                        if (marker.isAnimating && marker.animationScale) {
                            this.ctx.translate(centerX, centerY);
                            this.ctx.scale(marker.animationScale, marker.animationScale);
                            this.ctx.translate(-centerX, -centerY);
                        }
                        
                        // Multiple layered glow effects for golden shine
                        this.ctx.shadowColor = '#FFD700';
                        this.ctx.shadowBlur = isHovered ? 25 : 15;
                        
                        // Draw hexagonal mine entrance (outer shape)
                        this.ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI) / 3;
                            const x = centerX + Math.cos(angle) * size/2;
                            const y = centerY + Math.sin(angle) * size/2;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fillStyle = '#FFD700';
                        this.ctx.fill();
                        
                        // Inner hexagonal layer (mine depth)
                        this.ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI) / 3;
                            const x = centerX + Math.cos(angle) * size/2.5;
                            const y = centerY + Math.sin(angle) * size/2.5;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fillStyle = '#B8860B';
                        this.ctx.fill();
                        
                        // Core hexagonal layer (treasure chamber)
                        this.ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI) / 3;
                            const x = centerX + Math.cos(angle) * size/3;
                            const y = centerY + Math.sin(angle) * size/3;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fillStyle = '#FFF8DC';
                        this.ctx.fill();
                        
                        // Mine entrance highlight (top edge)
                        this.ctx.beginPath();
                        this.ctx.moveTo(centerX - size/2, centerY - size/2);
                        this.ctx.lineTo(centerX + size/2, centerY - size/2);
                        this.ctx.strokeStyle = '#FFFF00';
                        this.ctx.lineWidth = 3;
                        this.ctx.stroke();
                        
                        // Add rock texture details
                        this.ctx.fillStyle = '#8B6914';
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI * 2) / 8;
                            const dotX = centerX + Math.cos(angle) * (size/2.2);
                            const dotY = centerY + Math.sin(angle) * (size/2.2);
                            this.ctx.beginPath();
                            this.ctx.arc(dotX, dotY, 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // Add detailed sparkle effect with particles
                        const sparkleCount = isHovered ? 8 : 5; // More sparkles when hovered
                        for (let i = 0; i < sparkleCount; i++) {
                            const sparkleAngle = (i * Math.PI * 2) / sparkleCount;
                            const sparkleRadius = size * (isHovered ? 0.6 : 0.4); // Larger sparkle radius when hovered
                            const sparkleX = centerX + Math.cos(sparkleAngle) * sparkleRadius;
                            const sparkleY = centerY + Math.sin(sparkleAngle) * sparkleRadius;
                            
                            // Main sparkle
                            this.ctx.beginPath();
                            this.ctx.arc(sparkleX, sparkleY, isHovered ? 3 : 2, 0, Math.PI * 2);
                            this.ctx.fillStyle = '#FFFFFF';
                            this.ctx.fill();
                            
                            // Sparkle highlight
                            this.ctx.beginPath();
                            this.ctx.arc(sparkleX - 0.5, sparkleY - 0.5, isHovered ? 1.5 : 1, 0, Math.PI * 2);
                            this.ctx.fillStyle = '#FFFFE0';
                            this.ctx.fill();
                            
                            // Sparkle border
                            this.ctx.strokeStyle = '#FFD700';
                            this.ctx.lineWidth = 0.5;
                            this.ctx.stroke();
                        }
                        
                        // Add floating gold particles around the mine
                        if (isHovered) {
                            this.ctx.fillStyle = '#FFD700';
                            this.ctx.globalAlpha = 0.6;
                            for (let i = 0; i < 6; i++) {
                                const particleAngle = (i * Math.PI * 2) / 6 + Date.now() * 0.001;
                                const particleRadius = size * 0.8;
                                const particleX = centerX + Math.cos(particleAngle) * particleRadius;
                                const particleY = centerY + Math.sin(particleAngle) * particleRadius;
                                
                                this.ctx.beginPath();
                                this.ctx.arc(particleX, particleY, 1, 0, Math.PI * 2);
                                this.ctx.fill();
                            }
                            this.ctx.globalAlpha = 1.0;
                        }
                        
                        // Gold amount text with shadow
                        if (displaySize >= 8) {
                            this.ctx.shadowColor = '#000000';
                            this.ctx.shadowBlur = 2;
                            this.ctx.fillStyle = '#000';
                            this.ctx.font = `bold ${Math.max(8, displaySize * 0.3)}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            const amount = marker.amount ? marker.amount.toString() : '?';
                            this.ctx.fillText(amount, centerX, centerY);
                        }
                        
                        // Restore animation transformations
                        if (marker.isAnimating && marker.animationScale) {
                            this.ctx.restore();
                        }
                        
                        this.ctx.restore();
                        
                    } else if (marker.marker_type === 'oil') {
                        const x = marker.x * displaySize;
                        const y = marker.y * displaySize;
                        
                        // Enhanced oil platform marker - SAME SIZE as players and goldmines
                        const size = Math.max(displaySize * 5, 60); // Same as players and goldmines
                        const centerX = x + displaySize/2;
                        const centerY = y + displaySize/2;
                        
                        this.ctx.save();
                        
                        // Check if this marker is being hovered over
                        const isHovered = this.hoveredMarker && 
                            this.hoveredMarker.x === marker.x && 
                            this.hoveredMarker.y === marker.y && 
                            this.hoveredMarker.marker_type === 'oil';
                        
                        // Advanced oil well design - octagonal platform with depth
                        this.ctx.save();
                        
                        // Apply animation scaling if this marker is animating
                        if (marker.isAnimating && marker.animationScale) {
                            this.ctx.translate(centerX, centerY);
                            this.ctx.scale(marker.animationScale, marker.animationScale);
                            this.ctx.translate(-centerX, -centerY);
                        }
                        
                        // Dark oil base with glow and texture
                        this.ctx.shadowColor = '#000080';
                        this.ctx.shadowBlur = isHovered ? 15 : 8;
                        this.ctx.fillStyle = '#000080';
                        
                        // Draw octagonal oil platform
                        this.ctx.beginPath();
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI) / 4;
                            const x = centerX + Math.cos(angle) * size/2;
                            const y = centerY + Math.sin(angle) * size/2;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        
                        // Oil surface texture (concentric ripples)
                        this.ctx.strokeStyle = '#1E3A8A';
                        this.ctx.lineWidth = 2;
                        for (let i = 1; i <= 4; i++) {
                            const rippleSize = size * (0.2 + i * 0.15);
                            this.ctx.beginPath();
                            this.ctx.arc(centerX, centerY, rippleSize, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                        
                        // Oil platform border with depth
                        this.ctx.shadowBlur = 0;
                        this.ctx.strokeStyle = '#4169E1';
                        this.ctx.lineWidth = 3;
                        this.ctx.stroke();
                        
                        // Inner octagonal border for depth
                        this.ctx.strokeStyle = '#1E40AF';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI) / 4;
                            const x = centerX + Math.cos(angle) * (size/2 - 3);
                            const y = centerY + Math.sin(angle) * (size/2 - 3);
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.stroke();
                        
                        // Add detailed bubbling oil effect
                        const bubbleCount = isHovered ? 8 : 6; // More bubbles when hovered
                        for (let i = 0; i < bubbleCount; i++) {
                            const bubbleAngle = (i * Math.PI * 2) / bubbleCount;
                            const bubbleRadius = size * (isHovered ? 0.3 : 0.25); // Larger bubbles when hovered
                            const bubbleX = centerX + Math.cos(bubbleAngle) * bubbleRadius;
                            const bubbleY = centerY + Math.sin(bubbleAngle) * bubbleRadius;
                            
                            // Main bubble
                            this.ctx.beginPath();
                            this.ctx.arc(bubbleX, bubbleY, isHovered ? 2.5 : 2, 0, Math.PI * 2);
                            this.ctx.fillStyle = '#1E90FF';
                            this.ctx.fill();
                            
                            // Bubble highlight
                            this.ctx.beginPath();
                            this.ctx.arc(bubbleX - 0.5, bubbleY - 0.5, isHovered ? 1 : 0.8, 0, Math.PI * 2);
                            this.ctx.fillStyle = '#87CEEB';
                            this.ctx.fill();
                            
                            // Bubble border
                            this.ctx.strokeStyle = '#000080';
                            this.ctx.lineWidth = 0.5;
                            this.ctx.stroke();
                        }
                        
                        // Add oil surface reflections
                        this.ctx.fillStyle = '#1E90FF';
                        this.ctx.globalAlpha = 0.3;
                        for (let i = 0; i < 4; i++) {
                            const reflectionX = centerX + (Math.random() - 0.5) * size * 0.6;
                            const reflectionY = centerY + (Math.random() - 0.5) * size * 0.6;
                            this.ctx.beginPath();
                            this.ctx.arc(reflectionX, reflectionY, 1, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        this.ctx.globalAlpha = 1.0;
                        
                        // Oil amount text
                        if (displaySize >= 8) {
                            this.ctx.fillStyle = '#FFF';
                            this.ctx.font = `bold ${Math.max(8, displaySize * 0.3)}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            const amount = marker.amount ? marker.amount.toString() : '?';
                            this.ctx.fillText(amount, centerX, centerY);
                        }
                        
                        // Restore animation transformations
                        if (marker.isAnimating && marker.animationScale) {
                            this.ctx.restore();
                        }
                        
                        this.ctx.restore();
                    }
                }
            }

            renderUnits(displaySize) {
                // Unit rendering logic
            }

            renderPlayers(displaySize) {
                console.log('🎨 renderPlayers called, markers:', currentMapData.markers);
                if (!currentMapData.markers) {
                    console.log('🎨 No markers found in currentMapData');
                    return;
                }
                
                console.log(`🎨 Found ${currentMapData.markers.length} markers to render`);
                for (const marker of currentMapData.markers) {
                    console.log('🎨 Processing marker:', marker);
                    if (marker.marker_type === 'player') {
                        const x = marker.x * displaySize;
                        const y = marker.y * displaySize;
                        console.log(`🎨 Rendering player marker at pixel position (${x}, ${y}) from tile position (${marker.x}, ${marker.y}) with displaySize ${displaySize}`);
                        
                        // Player starting position marker - DOUBLE SIZE and much more detailed
                        const size = Math.max(displaySize * 5, 60); // Doubled from 2.5 to 5
                        
                        // Player color (different colors for different players)
                        const playerColors = [
                            '#FF0000', // Red
                            '#0000FF', // Blue  
                            '#00FF00', // Green
                            '#FFFF00', // Yellow
                            '#FF00FF', // Magenta
                            '#00FFFF', // Cyan
                            '#FFA500', // Orange
                            '#800080'  // Purple
                        ];
                        
                        const playerColor = playerColors[marker.player % playerColors.length];
                        
                        // Calculate center position
                        const centerX = x + displaySize/2;
                        const centerY = y + displaySize/2;
                        
                        // Draw chess piece style marker
                        this.ctx.save();
                        
                        // Check if this marker is being hovered over
                        const isHovered = this.hoveredMarker && 
                            this.hoveredMarker.x === marker.x && 
                            this.hoveredMarker.y === marker.y && 
                            this.hoveredMarker.marker_type === 'player';
                        
                        // Add subtle glow effect
                        this.ctx.shadowColor = playerColor;
                        this.ctx.shadowBlur = isHovered ? 20 : 8;
                        
                        // Apply animation scaling if this marker is animating
                        if (marker.isAnimating && marker.animationScale) {
                            this.ctx.save();
                            this.ctx.translate(centerX, centerY);
                            this.ctx.scale(marker.animationScale, marker.animationScale);
                            this.ctx.translate(-centerX, -centerY);
                        }
                        
                        // Draw advanced 3D chess piece base (pedestal) with enhanced detail
                        this.ctx.beginPath();
                        
                        // Create rounded rectangle base using path
                        const baseWidth = size * 2/3;
                        const baseHeight = size/6;
                        const baseX = centerX - baseWidth/2;
                        const baseY = centerY + size/3;
                        const cornerRadius = 4;
                        
                        // Rounded rectangle path
                        this.ctx.moveTo(baseX + cornerRadius, baseY);
                        this.ctx.lineTo(baseX + baseWidth - cornerRadius, baseY);
                        this.ctx.quadraticCurveTo(baseX + baseWidth, baseY, baseX + baseWidth, baseY + cornerRadius);
                        this.ctx.lineTo(baseX + baseWidth, baseY + baseHeight - cornerRadius);
                        this.ctx.quadraticCurveTo(baseX + baseWidth, baseY + baseHeight, baseX + baseWidth - cornerRadius, baseY + baseHeight);
                        this.ctx.lineTo(baseX + cornerRadius, baseY + baseHeight);
                        this.ctx.quadraticCurveTo(baseX, baseY + baseHeight, baseX, baseY + baseHeight - cornerRadius);
                        this.ctx.lineTo(baseX, baseY + cornerRadius);
                        this.ctx.quadraticCurveTo(baseX, baseY, baseX + cornerRadius, baseY);
                        this.ctx.closePath();
                        
                        // Main base with gradient-like effect
                        this.ctx.fillStyle = '#8B4513'; // Brown base
                        this.ctx.fill();
                        
                        // Base shadow/highlight for 3D effect (left side darker, right side lighter)
                        this.ctx.beginPath();
                        this.ctx.moveTo(baseX + 2, baseY + 1);
                        this.ctx.lineTo(baseX + baseWidth - 2, baseY + 1);
                        this.ctx.lineTo(baseX + baseWidth - 2, baseY + baseHeight - 1);
                        this.ctx.lineTo(baseX + 2, baseY + baseHeight - 1);
                        this.ctx.closePath();
                        this.ctx.fillStyle = '#A0522D'; // Lighter brown highlight
                        this.ctx.fill();
                        
                        // Base border with depth
                        this.ctx.strokeStyle = '#654321';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                        
                        // Add base texture (wood grain effect with curves)
                        this.ctx.strokeStyle = '#654321';
                        this.ctx.lineWidth = 1;
                        for (let i = 0; i < 3; i++) {
                            const lineY = baseY + 2 + i * 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(baseX + 4, lineY);
                            // Curved wood grain line
                            this.ctx.quadraticCurveTo(centerX, lineY + 1, baseX + baseWidth - 4, lineY);
                            this.ctx.stroke();
                        }
                        
                        // Draw advanced chess piece body with sophisticated tiered design
                        // Bottom tier (wider) - using path for more control
                        this.ctx.beginPath();
                        this.ctx.ellipse(centerX, centerY + size/6, size/2.2, size/3, 0, 0, Math.PI * 2);
                        this.ctx.fillStyle = playerColor;
                        this.ctx.fill();
                        
                        // Bottom tier highlight (right side)
                        this.ctx.beginPath();
                        this.ctx.ellipse(centerX + size/8, centerY + size/6, size/2.4, size/3.2, 0, 0, Math.PI * 2);
                        this.ctx.fillStyle = this.lightenColor(playerColor, 0.3);
                        this.ctx.fill();
                        
                        // Middle tier with enhanced shading
                        this.ctx.beginPath();
                        this.ctx.ellipse(centerX, centerY - size/8, size/1.8, size/2.5, 0, 0, Math.PI * 2);
                        this.ctx.fillStyle = this.lightenColor(playerColor, 0.2);
                        this.ctx.fill();
                        
                        // Middle tier highlight
                        this.ctx.beginPath();
                        this.ctx.ellipse(centerX + size/10, centerY - size/8, size/1.9, size/2.6, 0, 0, Math.PI * 2);
                        this.ctx.fillStyle = this.lightenColor(playerColor, 0.4);
                        this.ctx.fill();
                        
                        // Top tier (narrower) with peak
                        this.ctx.beginPath();
                        this.ctx.ellipse(centerX, centerY - size/3, size/1.4, size/2, 0, 0, Math.PI * 2);
                        this.ctx.fillStyle = this.lightenColor(playerColor, 0.4);
                        this.ctx.fill();
                        
                        // Top tier highlight
                        this.ctx.beginPath();
                        this.ctx.ellipse(centerX + size/12, centerY - size/3, size/1.5, size/2.1, 0, 0, Math.PI * 2);
                        this.ctx.fillStyle = this.lightenColor(playerColor, 0.6);
                        this.ctx.fill();
                        
                        // Body borders with enhanced depth and shading
                        this.ctx.strokeStyle = '#000000';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                        
                        // Add subtle inner borders for depth
                        this.ctx.strokeStyle = this.lightenColor(playerColor, 0.8);
                        this.ctx.lineWidth = 1;
                        this.ctx.stroke();
                        
                        // Draw detailed crown with jewels and enhanced detail
                        this.ctx.beginPath();
                        this.ctx.arc(centerX, centerY - size/3, size/4, 0, 2 * Math.PI);
                        this.ctx.fillStyle = isHovered ? '#FFFF00' : '#FFD700'; // Brighter crown when hovered
                        this.ctx.fill();
                        this.ctx.strokeStyle = '#B8860B';
                        this.ctx.lineWidth = isHovered ? 2 : 1; // Thicker border when hovered
                        this.ctx.stroke();
                        
                        // Add extra glow effect when hovered
                        if (isHovered) {
                            this.ctx.beginPath();
                            this.ctx.arc(centerX, centerY - size/3, size/4 + 2, 0, 2 * Math.PI);
                            this.ctx.strokeStyle = '#FFD700';
                            this.ctx.lineWidth = 1;
                            this.ctx.stroke();
                        }
                        
                        // Reset shadow for text
                        this.ctx.shadowBlur = 0;
                        
                        // Draw player number on the body
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = `bold ${Math.max(size * 0.3, 14)}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText((marker.player + 1).toString(), centerX, centerY);
                        
                        // Add race indicator (small icon)
                        const raceIcon = marker.race === 'Human' ? '⚔️' : '🛡️';
                        this.ctx.font = `${Math.max(size * 0.2, 10)}px Arial`;
                        this.ctx.fillText(raceIcon, centerX, centerY + size/3);
                        
                        // Restore animation transformations
                        if (marker.isAnimating && marker.animationScale) {
                            this.ctx.restore();
                        }
                        
                        this.ctx.restore();
                    }
                }
            }

            handleMouseMove(event) {
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // Check if mouse has moved enough to warrant tooltip update
                const deltaX = Math.abs(x - this.lastMouseX);
                const deltaY = Math.abs(y - this.lastMouseY);
                
                if (deltaX < this.mouseMoveThreshold && deltaY < this.mouseMoveThreshold) {
                    return; // Mouse hasn't moved enough, skip tooltip update
                }
                
                // Update last mouse position
                this.lastMouseX = x;
                this.lastMouseY = y;
                
                const displaySize = this.tileSize * this.zoomLevel;
                const tileX = Math.floor(x / displaySize);
                const tileY = Math.floor(y / displaySize);
                
                // Scale coordinates to internal canvas resolution for marker detection
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const canvasX = x * scaleX;
                const canvasY = y * scaleY;
                
                // Debounce tooltip display for performance improvement
                this.debounceTooltip(() => {
                    this.showTileTooltip(tileX, tileY, canvasX, canvasY, event.clientX, event.clientY);
                });
            }
            
            // Cleanup method for performance
            cleanup() {
                this.stopAnimations();
                if (this.tooltipTimeout) {
                    clearTimeout(this.tooltipTimeout);
                    this.tooltipTimeout = null;
                }
            }

            showTileTooltip(tileX, tileY, canvasX, canvasY, clientX, clientY) {
                if (!currentMapData) return;
                
                const tooltip = document.getElementById('tooltip');
                
                // Check for markers at this position with better detection
                // First try exact match, then check if we're within the marker's rendered area
                let marker = currentMapData.markers ? currentMapData.markers.find(m => 
                    m.x === tileX && m.y === tileY
                ) : null;
                
                // If no exact match, check if we're hovering over a marker's rendered area
                if (!marker && currentMapData.markers) {
                    const displaySize = this.tileSize * this.zoomLevel;
                    console.log(`🔍 Tooltip: Checking pixel-based marker detection. Canvas: (${canvasX}, ${canvasY}), DisplaySize: ${displaySize}`);
                    
                    marker = currentMapData.markers.find(m => {
                        // FAST CIRCLE COLLISION DETECTION using new simple bounds
                        const markerBounds = this.getMarkerRenderBounds(m, displaySize);
                        
                        // Calculate distance from mouse to marker center
                        const dx = canvasX - markerBounds.centerX;
                        const dy = canvasY - markerBounds.centerY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        const isWithinBounds = distance <= markerBounds.radius;
                        
                        // Debug: Show what we're checking
                        console.log(`🔍 Checking marker ${m.marker_type} at tile (${m.x}, ${m.y}) → center: (${markerBounds.centerX}, ${markerBounds.centerY}), radius: ${markerBounds.radius}`);
                        console.log(`🔍 Mouse at canvas (${canvasX}, ${canvasY}) - Distance: ${distance.toFixed(1)}, Within bounds: ${isWithinBounds}`);
                        
                        if (isWithinBounds) {
                            console.log(`🎯 Tooltip: Found marker via circle detection:`, m);
                        }
                        
                        // Check if mouse is within the marker's circle bounds
                        return isWithinBounds;
                    });
                }
                
                // If we have a marker, prioritize showing marker information
                if (marker) {
                    console.log(`🎯 Tooltip: Found marker at (${tileX}, ${tileY}):`, marker);
                    
                    let markerIcon = '';
                    let markerColor = '';
                    
                    // Set appropriate icon and color based on marker type
                    if (marker.marker_type === 'player') {
                        markerIcon = '👤';
                        markerColor = marker.race === 'Human' ? '#FF6B6B' : '#4ECDC4';
                    } else if (marker.marker_type === 'goldmine') {
                        markerIcon = '💰';
                        markerColor = '#FFD700';
                    } else if (marker.marker_type === 'oil') {
                        markerIcon = '🛢️';
                        markerColor = '#000080';
                    }
                    
                    tooltip.innerHTML = `
                        <div class="tooltip-header" style="color: ${markerColor}">${markerIcon} ${marker.marker_type.toUpperCase()}</div>
                        <div class="tooltip-content">
                            <strong>Position:</strong> (${tileX}, ${tileY})<br>
                            <strong>Label:</strong> ${marker.label}<br>
                            ${marker.description ? `<strong>Description:</strong> ${marker.description}<br>` : ''}
                            ${marker.amount ? `<strong>Gold Amount:</strong> <span style="color: #FFD700; font-weight: bold;">${marker.amount.toLocaleString()}</span><br>` : ''}
                            ${marker.race ? `<strong>Race:</strong> <span style="color: ${marker.race === 'Human' ? '#FF6B6B' : '#4ECDC4'}; font-weight: bold;">${marker.race}</span><br>` : ''}
                            ${marker.player !== undefined ? `<strong>Player Number:</strong> <span style="color: #FFD700; font-weight: bold;">${marker.player + 1}</span><br>` : ''}
                            ${marker.marker_type === 'player' ? `<strong>Starting Resources:</strong> 1000 Gold, 500 Lumber, 200 Oil<br>` : ''}
                            ${marker.marker_type === 'goldmine' ? `<strong>Mine Type:</strong> Neutral Goldmine<br>` : ''}
                            <br>
                            <div style="font-size: 0.9em; opacity: 0.8; border-top: 1px solid #444; padding-top: 8px;">
                                <strong>Tile Info:</strong><br>
                                <strong>Terrain:</strong> ${this.textureManager.getTerrainType(currentMapData.terrain ? currentMapData.terrain[tileY * currentMapData.width + tileX] : 0, currentMapData.tileset)}<br>
                                <strong>Tileset:</strong> ${this.getTilesetName(currentMapData.tileset)}
                            </div>
                        </div>
                    `;
                } else {
                    // No marker, show regular tile information
                    console.log(`🔍 Tooltip: No marker found at (${tileX}, ${tileY}), showing tile info`);
                    const tileIndex = tileY * currentMapData.width + tileX;
                    const tileId = currentMapData.terrain ? currentMapData.terrain[tileIndex] : 'N/A';
                    const terrainType = this.textureManager.getTerrainType(tileId, currentMapData.tileset);
                    
                    tooltip.innerHTML = `
                        <div class="tooltip-header">🔍 Tile Information</div>
                        <div class="tooltip-content">
                            <strong>Position:</strong> (${tileX}, ${tileY})<br>
                            <strong>Tile ID:</strong> ${tileId} (${tileId !== 'N/A' ? '0x' + parseInt(tileId).toString(16).toUpperCase() : 'N/A'})<br>
                            <strong>Tileset:</strong> ${currentMapData.tileset} (${this.getTilesetName(currentMapData.tileset)})<br>
                            <strong>Terrain:</strong> ${terrainType}<br>
                            <strong>Color:</strong> <span style="color: ${this.textureManager.getFallbackColorForTerrainType(terrainType)}">${this.textureManager.getFallbackColorForTerrainType(terrainType)}</span><br>
                            <strong>Range:</strong> ${this.getTileRange(tileId)}
                        </div>
                    `;
                }
                
                // Position tooltip closer to cursor and ensure it stays within viewport
                const tooltipWidth = 320;
                const tooltipHeight = marker ? 280 : 140; // Larger for markers
                
                // Add hover effect to the marker if we found one
                if (marker) {
                    this.addMarkerHoverEffect(marker);
                }
                const padding = 10;
                
                let left = clientX + 15;
                let top = clientY + 15;
                
                // Adjust if tooltip would go off the right edge
                if (left + tooltipWidth > window.innerWidth) {
                    left = clientX - tooltipWidth - 15;
                }
                
                // Adjust if tooltip would go off the bottom edge
                if (top + tooltipHeight > window.innerHeight) {
                    top = clientY - tooltipHeight - 15;
                }
                
                // Ensure tooltip doesn't go off the left or top edges
                left = Math.max(padding, left);
                top = Math.max(padding, top);
                
                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
                tooltip.style.display = 'block';
                
                // Add animation class after a brief delay
                setTimeout(() => {
                    tooltip.classList.add('show');
                }, 10);
            }

            hideTooltip() {
                // Clear any pending tooltip timeout
                if (this.tooltipTimeout) {
                    clearTimeout(this.tooltipTimeout);
                    this.tooltipTimeout = null;
                }
                
                const tooltip = document.getElementById('tooltip');
                if (tooltip) {
                    tooltip.classList.remove('show');
                    tooltip.style.display = 'none';
                }
                
                // Remove hover effects from all markers
                this.removeMarkerHoverEffects();
            }
            
            addMarkerHoverEffect(marker) {
                // Store the hovered marker for rendering enhancement
                this.hoveredMarker = marker;
                
                // Add animation properties
                marker.animationStartTime = Date.now();
                marker.isAnimating = true;
                
                // Add to batched animation system
                this.pendingAnimations.add(marker);
                
                // Trigger a redraw to show enhanced effects
                this.redraw();
            }
            
            // Individual marker animation method removed - now using batched system for performance
            
            removeMarkerHoverEffects() {
                // Stop all marker animations
                if (currentMapData && currentMapData.markers) {
                    currentMapData.markers.forEach(marker => {
                        marker.isAnimating = false;
                        marker.animationProgress = 0;
                        marker.animationScale = 1;
                        marker.animationRotation = 0;
                        marker.animationGlow = 1;
                    });
                }
                
                // Clear pending animations
                this.pendingAnimations.clear();
                
                // Clear the hovered marker
                this.hoveredMarker = null;
                
                // Trigger a redraw to remove enhanced effects
                this.redraw();
            }
            
            /**
             * Debounce tooltip display for performance improvement
             * Prevents excessive tooltip updates during rapid mouse movement
             */
            debounceTooltip(callback) {
                // Clear existing timeout
                if (this.tooltipTimeout) {
                    clearTimeout(this.tooltipTimeout);
                }
                
                // Set new timeout with slight delay for performance
                this.tooltipTimeout = setTimeout(() => {
                    callback();
                }, 150); // 150ms delay - slight but noticeable performance improvement
            }
            
            // Track last mouse position to prevent excessive tooltip updates
            lastMouseX = 0;
            lastMouseY = 0;
            mouseMoveThreshold = 3; // Minimum pixels moved before updating tooltip
            
            // Helper function to lighten colors for 3D effects
            lightenColor(color, factor) {
                // Convert hex to RGB
                const hex = color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                
                // Lighten by factor
                const newR = Math.min(255, Math.round(r + (255 - r) * factor));
                const newG = Math.min(255, Math.round(g + (255 - g) * factor));
                const newB = Math.min(255, Math.round(b + (255 - b) * factor));
                
                // Convert back to hex
                return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
            }

            /**
             * Calculate the actual rendered bounds for a marker based on its type and display size
             */
            getMarkerRenderBounds(marker, displaySize) {
                // SIMPLE CIRCLE BOUNDS - Much faster than complex path detection
                const baseX = marker.x * displaySize;
                const baseY = marker.y * displaySize;
                const centerX = baseX + displaySize/2;
                const centerY = baseY + displaySize/2;
                
                // All markers now use consistent size for performance
                const radius = Math.max(displaySize * 2.5, 30); // Optimized size
                
                return {
                    centerX: centerX,
                    centerY: centerY,
                    radius: radius,
                    // Simple circle bounds for fast collision detection
                    bounds: {
                        x: centerX - radius,
                        y: centerY - radius,
                        width: radius * 2,
                        height: radius * 2
                    }
                };
            }

            /**
             * Get tileset name from ID (based on war2tools specifications)
             */
            getTilesetName(tilesetId) {
                const tilesets = {
                    0: 'Forest',
                    1: 'Winter', 
                    2: 'Wasteland',
                    3: 'Swamp'
                };
                return tilesets[tilesetId] || 'Unknown';
            }

            /**
             * Get tile range description (based on war2tools tile mapping)
             */
            getTileRange(tileId) {
                if (tileId === 'N/A') return 'Unknown';
                
                if (tileId >= 0 && tileId <= 15) return 'Basic Grass (0x00-0x0F)';
                if (tileId >= 16 && tileId <= 47) return 'Water (0x10-0x2F)';
                if (tileId >= 48 && tileId <= 79) return 'Coast (0x30-0x4F)';
                if (tileId >= 80 && tileId <= 95) return 'Ground Variations (0x50-0x5F)';
                if (tileId >= 96 && tileId <= 111) return 'Rock/Mountain (0x60-0x6F)';
                if (tileId >= 112 && tileId <= 127) return 'Forest/Trees (0x70-0x7F)';
                if (tileId >= 128) return 'Extended Variations (0x80+)';
                
                return 'Unknown Range';
            }
        }

        // Event Listeners
        function setupEventListeners() {
            // File input
            document.getElementById('mapFile').addEventListener('change', handleFileSelect);
            
            // Rendering mode buttons
            document.getElementById('textureMode').addEventListener('click', () => setRenderingMode('texture'));
            document.getElementById('colorMode').addEventListener('click', () => setRenderingMode('color'));
            document.getElementById('hybridMode').addEventListener('click', () => setRenderingMode('hybrid'));
            
            // System buttons
            document.getElementById('extractTextures').addEventListener('click', extractTextures);
            document.getElementById('clearCache').addEventListener('click', clearCache);
            
            // Zoom slider with LOD support
            document.getElementById('zoomSlider').addEventListener('input', (e) => {
                const zoom = parseInt(e.target.value);
                document.getElementById('zoomValue').textContent = zoom + 'x';
                if (mapRenderer) {
                    mapRenderer.setZoom(zoom);
                }
            });
            
            // Zoom buttons for quick access
            document.getElementById('zoomIn').addEventListener('click', () => {
                if (mapRenderer) {
                    const currentZoom = mapRenderer.zoomLevel;
                    const nextZoom = Math.min(32, currentZoom + 2);
                    mapRenderer.setZoom(nextZoom);
                    document.getElementById('zoomSlider').value = nextZoom;
                    document.getElementById('zoomValue').textContent = nextZoom + 'x';
                }
            });
            
            document.getElementById('zoomOut').addEventListener('click', () => {
                if (mapRenderer) {
                    const currentZoom = mapRenderer.zoomLevel;
                    const prevZoom = Math.max(4, currentZoom - 2);
                    mapRenderer.setZoom(prevZoom);
                    document.getElementById('zoomSlider').value = prevZoom;
                    document.getElementById('zoomValue').textContent = prevZoom + 'x';
                }
            });
            
            // Zoom reset button
            document.getElementById('zoomReset').addEventListener('click', () => {
                if (mapRenderer) {
                    mapRenderer.setZoom(8);
                    document.getElementById('zoomSlider').value = 8;
                    document.getElementById('zoomValue').textContent = '8x';
                }
            });
            
            // Overlay toggles
            document.getElementById('showResources').addEventListener('change', (e) => {
                if (mapRenderer) mapRenderer.setOverlays({ resources: e.target.checked });
            });
            
            document.getElementById('showUnits').addEventListener('change', (e) => {
                if (mapRenderer) mapRenderer.setOverlays({ units: e.target.checked });
            });
            
            document.getElementById('showPlayers').addEventListener('change', (e) => {
                if (mapRenderer) mapRenderer.setOverlays({ players: e.target.checked });
            });
            
            // Tileset selection - change immediately when selected
            document.getElementById('tilesetSelector').addEventListener('change', (e) => {
                const selectedTileset = parseInt(e.target.value);
                if (currentMapData && mapRenderer) {
                    // Update the map data with new tileset
                    currentMapData.tileset = selectedTileset;
                    
                    // Re-render the map with new tileset
                    mapRenderer.renderMap(currentMapData);
                    
                    // Update map information display
                    updateMapInfo(currentMapData);
                    
                    // Show status
                    const tilesetName = textureManager.getTilesetName(selectedTileset);
                    showStatus(`Tileset changed to ${tilesetName}!`, 'success');
                    
                    console.log(`🎨 Tileset changed to ${selectedTileset} (${tilesetName})`);
                }
            });
        }

        // File handling
        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                showStatus('Loading map file...', 'loading');
                
                // Read the PUD file
                const arrayBuffer = await file.arrayBuffer();
                const fileData = new Uint8Array(arrayBuffer);
                
                // Parse PUD file using JavaScript parser
                console.log('🔧 Creating FixedBinaryParser instance...');
                const binaryParser = new FixedBinaryParser(); // Use the fixed parser
                console.log('✅ FixedBinaryParser instance created:', binaryParser);
                
                console.log('🔧 Starting PUD file parsing...');
                const mapData = binaryParser.parsePudFile(fileData);
                console.log('✅ PUD file parsing completed');
                
                console.log('Parsed map data:', mapData);
                                 console.log('Map dimensions:', mapData.width, 'x', mapData.height);
                 console.log('Terrain runs:', mapData.terrain_runs?.length || 0);
                 console.log('Markers:', mapData.markers?.length || 0);
                 console.log('Tileset:', mapData.tileset);
                 
                 // Debug: Show all markers found
                 if (mapData.markers && mapData.markers.length > 0) {
                     console.log('🔍 All markers found:');
                     mapData.markers.forEach((marker, index) => {
                         console.log(`  ${index + 1}. ${marker.marker_type} at (${marker.x}, ${marker.y}) - ${marker.label}`);
                     });
                 } else {
                     console.log('⚠️ No markers found in map');
                 }
                
                // Render the map
                await mapRenderer.renderMap(mapData);
                
                // Update map information display
                updateMapInfo(mapData);
                
                // Show tileset information
                const tilesetName = textureManager.getTilesetName(mapData.tileset);
                showStatus(`Map loaded successfully! Tileset: ${tilesetName}`, 'success');
                
                // Log tileset details
                console.log(`🎨 Map tileset: ${mapData.tileset} (${tilesetName})`);
                console.log(`🎨 Terrain classification will use ${tilesetName} color scheme`);
                
            } catch (error) {
                console.error('❌ Failed to load map:', error);
                showStatus('Failed to load map: ' + error.message, 'error');
            }
        }

        // Rendering mode functions
        function setRenderingMode(mode) {
            console.log(`🎨 Setting rendering mode to: ${mode}`);
            // Implementation would switch between texture, color, and hybrid modes
        }

        // Texture extraction
        async function extractTextures() {
            try {
                showStatus('Extracting textures...', 'loading');
                
                if (textureManager) {
                    await textureManager.initializeWithoutWasm();
                    updateTextureStats();
                    showStatus('Color-based textures ready!', 'success');
                }
                
            } catch (error) {
                console.error('❌ Texture extraction failed:', error);
                showStatus('Texture extraction failed: ' + error.message, 'error');
            }
        }

        // Cache management
        function clearCache() {
            if (textureManager) {
                textureManager.clearCache();
                updateTextureStats();
                showStatus('Cache cleared!', 'success');
            }
        }

        // Utility functions
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function updateTextureStats() {
            if (textureManager) {
                const stats = textureManager.getStats();
                document.getElementById('textureStatus').textContent = stats.isLoaded ? '✅' : '❌';
                document.getElementById('cachedTextures').textContent = stats.cachedTextures;
                document.getElementById('totalTextures').textContent = stats.totalTextures;
                document.getElementById('totalSize').textContent = Math.round(stats.totalSize / 1024) + ' KB';
            }
        }
        
        function updatePerformanceMonitor() {
            if (mapRenderer) {
                document.getElementById('fpsDisplay').textContent = mapRenderer.fps || '--';
                document.getElementById('redrawCount').textContent = mapRenderer.frameCount || '--';
                
                // Update performance status
                const statusElement = document.getElementById('performanceStatus');
                if (mapRenderer.fps >= 55) {
                    statusElement.textContent = 'Excellent';
                    statusElement.style.color = '#2ECC71';
                } else if (mapRenderer.fps >= 30) {
                    statusElement.textContent = 'Good';
                    statusElement.style.color = '#F39C12';
                } else {
                    statusElement.textContent = 'Poor';
                    statusElement.style.color = '#E74C3C';
                }
            }
        }

        function updateMapInfo(mapData) {
            if (mapData) {
                const tilesetName = textureManager.getTilesetName(mapData.tileset);
                document.getElementById('mapTileset').textContent = tilesetName;
                document.getElementById('mapDimensions').textContent = `${mapData.width}×${mapData.height}`;
                document.getElementById('mapMarkers').textContent = mapData.markers?.length || 0;
                document.getElementById('mapTerrain').textContent = mapData.terrain_runs?.length || 0;
                
                // Update tileset selector to show current tileset
                document.getElementById('tilesetSelector').value = mapData.tileset;
            }
        }

        // previewSelectedTileset function removed - tileset changes immediately on selection

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
