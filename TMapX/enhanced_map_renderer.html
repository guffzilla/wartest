<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎨 Enhanced Warcraft II Map Renderer - Texture-Based</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin: 0;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
            margin: 10px 0;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-group h3 {
            margin: 0 0 10px 0;
            color: #FFD700;
        }

        .btn {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #333;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .file-input {
            display: none;
        }

        .file-label {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            display: inline-block;
            transition: all 0.3s ease;
        }

        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }

        .map-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .map-visualization {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #FFD700;
        }

        .map-canvas {
            border: 2px solid #333;
            background: #333;
            display: block;
            margin: 0 auto;
            max-width: 100%;
        }

        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #FFD700;
        }

        .zoom-controls {
            margin: 20px 0;
            text-align: center;
        }

        .zoom-slider {
            width: 100%;
            margin: 10px 0;
        }

        .zoom-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #FFD700;
        }

        .texture-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .texture-info h4 {
            margin: 0 0 10px 0;
            color: #FFD700;
        }

        .texture-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 8px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #FFD700;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
        }

        .status.loading {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #FFC107;
            color: #FFC107;
        }

        .status.success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
            color: #4CAF50;
        }

        .status.error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #F44336;
            color: #F44336;
        }

        .overlay-controls {
            margin: 20px 0;
        }

        .overlay-toggle {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }

        .overlay-toggle input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }

        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1000;
            border: 2px solid #4169E1;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            min-width: 220px;
            max-width: 320px;
            backdrop-filter: blur(5px);
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        
        .tooltip.show {
            opacity: 1;
            transform: scale(1);
        }

        .tooltip-header {
            color: #FFD700;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .tooltip-content {
            line-height: 1.5;
        }
        
        .tooltip-marker {
            margin-top: 8px;
            padding: 8px;
            background: rgba(255, 215, 0, 0.1);
            border-left: 3px solid #FFD700;
            border-radius: 4px;
        }

        .tooltip-player {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(78, 205, 196, 0.1));
            border-left: 3px solid #FFD700;
            border-radius: 6px;
            padding: 10px;
            margin-top: 5px;
        }

        .tooltip-goldmine {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 193, 7, 0.1));
            border-left: 3px solid #FFD700;
            border-radius: 6px;
            padding: 10px;
            margin-top: 5px;
        }
        
        /* Enhanced marker hover effects */
        .marker-hover {
            animation: pulse 1.5s ease-in-out infinite alternate;
        }
        
        @keyframes pulse {
            from {
                transform: scale(1);
                opacity: 1;
            }
            to {
                transform: scale(1.05);
                opacity: 0.8;
            }
        }
        
        /* Goldmine sparkle animation */
        .goldmine-sparkle {
            animation: sparkle 2s ease-in-out infinite;
        }
        
        @keyframes sparkle {
            0%, 100% { opacity: 0.3; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1.2); }
        }
        
        /* Oil bubble animation */
        .oil-bubble {
            animation: bubble 3s ease-in-out infinite;
        }
        
        @keyframes bubble {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-2px) scale(1.1); }
        }
        
        /* Chess piece crown animation */
        .crown-jewel {
            animation: jewel-shine 4s ease-in-out infinite;
        }
        
        @keyframes jewel-shine {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            25% { opacity: 1; transform: scale(1.1); }
            50% { opacity: 0.9; transform: scale(1.05); }
            75% { opacity: 1; transform: scale(1.15); }
        }
        
        /* Goldmine texture animation */
        .goldmine-texture {
            animation: texture-rotate 8s linear infinite;
        }
        
        @keyframes texture-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Oil ripple animation */
        .oil-ripple {
            animation: ripple-expand 6s ease-out infinite;
        }
        
        @keyframes ripple-expand {
            0% { transform: scale(0.8); opacity: 0.8; }
            100% { transform: scale(1.2); opacity: 0; }
        }
        
        /* Status banner pulse animation */
        @keyframes statusPulse {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            }
            50% { 
                transform: scale(1.02); 
                box-shadow: 0 8px 30px rgba(0,0,0,0.5);
            }
        }

        @media (max-width: 1200px) {
            .map-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎨 Enhanced Warcraft II Map Renderer</h1>
            <p>Texture-Based Rendering with Authentic Warcraft II Visuals</p>
            <div id="graphicsStatus" style="background: linear-gradient(45deg, #FF6B6B, #4ECDC4, #45B7D1, #96CEB4, #FFEAA7); padding: 10px; border-radius: 8px; margin-top: 10px; text-align: center; color: white; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); animation: statusPulse 3s ease-in-out infinite;">
                ✨ SUPER ENHANCED GRAPHICS LOADED ✨<br>
                🎯 Chess Piece Players | 💎 Multi-Layer Goldmines | 🛢️ Bubbling Oil Patches
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>📁 Map File</h3>
                <input type="file" id="mapFile" class="file-input" accept=".pud">
                <label for="mapFile" class="file-label">Choose PUD File</label>
            </div>

            <div class="control-group">
                <h3>🎨 Rendering Mode</h3>
                <button id="textureMode" class="btn">🖼️ Texture Mode</button>
                <button id="colorMode" class="btn">🎨 Color Mode</button>
                <button id="hybridMode" class="btn">🔄 Hybrid Mode</button>
            </div>

            <div class="control-group">
                <h3>⚙️ System</h3>
                <button id="extractTextures" class="btn">🔍 Extract Textures</button>
                <button id="clearCache" class="btn">🗑️ Clear Cache</button>
            </div>

            <div class="control-group">
                <h3>🎨 Tileset Preview</h3>
                <select id="tilesetSelector" class="btn" style="background: #4169E1;">
                    <option value="0">🌲 Forest</option>
                    <option value="1">❄️ Winter</option>
                    <option value="2">🏜️ Wasteland</option>
                    <option value="3">🌿 Swamp</option>
                </select>
                <button id="previewTileset" class="btn">👁️ Preview</button>
            </div>
        </div>

        <div class="map-container">
            <div class="map-visualization">
                <canvas id="mapCanvas" class="map-canvas" width="800" height="600"></canvas>
                
                <div class="zoom-controls">
                    <div class="zoom-value" id="zoomValue">1x</div>
                    <input type="range" id="zoomSlider" class="zoom-slider" min="1" max="8" value="1" step="1">
                </div>
            </div>

            <div class="sidebar">
                <div class="texture-info">
                    <h4>🎨 Texture System Status</h4>
                    <div class="texture-stats">
                        <div class="stat-item">
                            <div class="stat-value" id="textureStatus">❌</div>
                            <div class="stat-label">Status</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="cachedTextures">0</div>
                            <div class="stat-label">Cached</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalTextures">0</div>
                            <div class="stat-label">Total</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalSize">0 KB</div>
                            <div class="stat-label">Size</div>
                        </div>
                    </div>
                </div>

                <div class="texture-info">
                    <h4>🗺️ Map Information</h4>
                    <div class="texture-stats">
                        <div class="stat-item">
                            <div class="stat-value" id="mapTileset">-</div>
                            <div class="stat-label">Tileset</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="mapDimensions">-</div>
                            <div class="stat-label">Dimensions</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="mapMarkers">-</div>
                            <div class="stat-label">Markers</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="mapTerrain">-</div>
                            <div class="stat-label">Terrain</div>
                        </div>
                    </div>
                </div>

                <div class="overlay-controls">
                    <h4>🎯 Overlays</h4>
                    <div class="overlay-toggle">
                        <input type="checkbox" id="showResources" checked>
                        <label for="showResources">💰 Resources</label>
                    </div>
                    <div class="overlay-toggle">
                        <input type="checkbox" id="showUnits" checked>
                        <label for="showUnits">⚔️ Units</label>
                    </div>
                    <div class="overlay-toggle">
                        <input type="checkbox" id="showPlayers" checked>
                        <label for="showPlayers">👤 Players</label>
                    </div>
                </div>

                <div id="status" class="status"></div>
            </div>
        </div>
    </div>

    <div id="tooltip" class="tooltip" style="display: none;"></div>

    <script src="binary_parser_fixed.js"></script>
    <script type="module">
        import { TextureManager } from './texture_manager.js';

        let textureManager = null;
        let mapRenderer = null;
        let currentMapData = null;

        // Initialize the application
        async function initializeApp() {
            try {
                showStatus('Initializing system...', 'loading');
                
                // Check if FixedBinaryParser is loaded
                if (typeof FixedBinaryParser === 'undefined') {
                    throw new Error('FixedBinaryParser not loaded! Check if binary_parser_fixed.js is accessible.');
                }
                console.log('✅ FixedBinaryParser loaded successfully:', FixedBinaryParser);
                
                // Initialize texture manager (no WASM needed)
                textureManager = new TextureManager();
                await textureManager.initializeWithoutWasm();
                
                // Initialize map renderer
                mapRenderer = new EnhancedMapRenderer('mapCanvas', textureManager);
                
                showStatus('System ready!', 'success');
                updateTextureStats();
                
                // Set up event listeners
                setupEventListeners();
                
            } catch (error) {
                console.error('❌ Initialization failed:', error);
                showStatus('Initialization failed: ' + error.message, 'error');
            }
        }

        // Enhanced Map Renderer Class
        class EnhancedMapRenderer {
            constructor(canvasId, textureManager) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.textureManager = textureManager;
                this.zoomLevel = 8;
                this.tileSize = 12;
                this.overlays = {
                    resources: true,
                    units: true,
                    players: true
                };
                
                this.setupCanvas();
            }

            setupCanvas() {
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseleave', this.hideTooltip.bind(this));
            }

            setZoom(level) {
                this.zoomLevel = level;
                this.redraw();
            }

            setOverlays(overlays) {
                this.overlays = { ...this.overlays, ...overlays };
                // Only redraw overlays, not the entire map
                this.redrawOverlays();
            }
            
            redrawOverlays() {
                if (!currentMapData) return;
                
                // Just redraw the entire map to ensure overlays are visible
                console.log('🎨 Redrawing entire map to ensure overlays are visible');
                this.redraw();
            }

            async renderMap(mapData) {
                currentMapData = mapData;
                this.redraw();
            }

            redraw() {
                if (!currentMapData) return;
                
                const displaySize = this.tileSize * this.zoomLevel;
                const newWidth = currentMapData.width * displaySize;
                const newHeight = currentMapData.height * displaySize;
                
                // Only resize canvas if dimensions actually changed
                if (this.canvas.width !== newWidth || this.canvas.height !== newHeight) {
                    this.canvas.width = newWidth;
                    this.canvas.height = newHeight;
                }
                
                // Clear canvas
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Render terrain
                this.renderTerrain(displaySize);
                
                // ALWAYS render overlays after terrain - don't check overlay settings here
                // This ensures overlays are always drawn and visible
                console.log('🎨 Rendering ALL overlays after terrain');
                this.renderResources(displaySize);
                this.renderUnits(displaySize);
                this.renderPlayers(displaySize);
            }

            renderTerrain(displaySize) {
                if (!currentMapData.terrain_runs) return;
                
                // Create a 2D array to store terrain data
                const terrainGrid = [];
                for (let y = 0; y < currentMapData.height; y++) {
                    terrainGrid[y] = [];
                    for (let x = 0; x < currentMapData.width; x++) {
                        terrainGrid[y][x] = { tile_id: 0, terrain_type: 'grass' };
                    }
                }
                
                // Fill the terrain grid from runs
                let currentTile = 0;
                for (const run of currentMapData.terrain_runs) {
                    for (let i = 0; i < run.count; i++) {
                        const tileIndex = currentTile + i;
                        const x = tileIndex % currentMapData.width;
                        const y = Math.floor(tileIndex / currentMapData.width);
                        
                        if (y < currentMapData.height && x < currentMapData.width) {
                            terrainGrid[y][x] = {
                                tile_id: run.tile_id,
                                terrain_type: run.terrain_type
                            };
                        }
                    }
                    currentTile += run.count;
                }
                
                // Render the terrain grid
                for (let y = 0; y < currentMapData.height; y++) {
                    for (let x = 0; x < currentMapData.width; x++) {
                        const tile = terrainGrid[y][x];
                        const renderX = x * displaySize;
                        const renderY = y * displaySize;
                        
                        // Use texture manager to render tile with tileset support
                        this.textureManager.renderFallbackTileWithTerrainType(
                            this.ctx,
                            tile.terrain_type,
                            renderX,
                            renderY,
                            displaySize,
                            currentMapData.tileset
                        );
                    }
                }
                
                // Add big blue "G" in the center of the map to show advanced graphics are working
                this.drawCenterIndicator(displaySize);
            }
            
            drawCenterIndicator(displaySize) {
                const centerX = (currentMapData.width / 2) * displaySize;
                const centerY = (currentMapData.height / 2) * displaySize;
                
                // Draw a large blue "G" in the center with continuous animation
                this.ctx.save();
                
                // Add animated glow effect
                const time = Date.now() * 0.001;
                const glowIntensity = 15 + Math.sin(time * 3) * 10;
                this.ctx.shadowColor = '#0066FF';
                this.ctx.shadowBlur = glowIntensity;
                
                // Draw background circle - DOUBLE SIZE with animation
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, displaySize * 4, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(0, 102, 255, 0.1)';
                this.ctx.fill();
                
                // Draw the big blue "G" - DOUBLE SIZE with rotation animation
                this.ctx.save();
                this.ctx.translate(centerX, centerY);
                this.ctx.rotate(Math.sin(time * 2) * 0.1); // Gentle rotation
                this.ctx.fillStyle = '#0066FF';
                this.ctx.font = `bold ${displaySize * 6}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('G', 0, 0);
                this.ctx.restore();
                
                // Add border - DOUBLE SIZE with pulsing
                const borderWidth = 8 + Math.sin(time * 4) * 2;
                this.ctx.strokeStyle = '#0033CC';
                this.ctx.lineWidth = borderWidth;
                this.ctx.stroke();
                
                // Add animated sparkles around it - DOUBLE SIZE
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.globalAlpha = 0.8;
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI * 2) / 6 + time * 2; // Rotating sparkles
                    const radius = displaySize * 5 + Math.sin(time * 3 + i) * 10; // Pulsing radius
                    const sparkleX = centerX + Math.cos(angle) * radius;
                    const sparkleY = centerY + Math.sin(angle) * radius;
                    
                    // Animated sparkle size
                    const sparkleSize = 6 + Math.sin(time * 5 + i) * 3;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1.0;
                
                // Add floating particles around the G
                this.ctx.fillStyle = '#87CEEB';
                this.ctx.globalAlpha = 0.6;
                for (let i = 0; i < 8; i++) {
                    const particleAngle = time * 1.5 + i * Math.PI / 4;
                    const particleRadius = displaySize * 3 + Math.sin(time * 2 + i) * 20;
                    const particleX = centerX + Math.cos(particleAngle) * particleRadius;
                    const particleY = centerY + Math.sin(particleAngle) * particleRadius;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1.0;
                
                this.ctx.restore();
                
                // Continue animation loop
                requestAnimationFrame(() => this.drawCenterIndicator(displaySize));
                
                console.log('🎯 Center indicator "G" drawn at:', centerX, centerY, 'with animations');
            }

            renderResources(displaySize) {
                console.log('🎨 renderResources called, markers:', currentMapData.markers);
                if (!currentMapData.markers) {
                    console.log('🎨 No markers found in currentMapData for resources');
                    return;
                }
                
                console.log(`🎨 Found ${currentMapData.markers.length} markers to check for resources`);
                for (const marker of currentMapData.markers) {
                    console.log('🎨 Checking marker for resources:', marker);
                    if (marker.marker_type === 'goldmine') {
                        const x = marker.x * displaySize;
                        const y = marker.y * displaySize;
                        
                        // Enhanced goldmine marker - DOUBLE SIZE golden shining mine
                        const radius = Math.max(displaySize * 0.8, 8); // Doubled from 0.4 to 0.8
                        const centerX = x + displaySize/2;
                        const centerY = y + displaySize/2;
                        
                        this.ctx.save();
                        
                        // Check if this marker is being hovered over
                        const isHovered = this.hoveredMarker && 
                            this.hoveredMarker.x === marker.x && 
                            this.hoveredMarker.y === marker.y && 
                            this.hoveredMarker.marker_type === 'goldmine';
                        
                        // Multiple layered glow effects for golden shine
                        this.ctx.shadowColor = '#FFD700';
                        this.ctx.shadowBlur = isHovered ? 25 : 15;
                        
                        // Outer golden ring with texture
                        this.ctx.beginPath();
                        this.ctx.arc(centerX, centerY, radius + 2, 0, Math.PI * 2);
                        this.ctx.fillStyle = '#FFD700';
                        this.ctx.fill();
                        
                        // Add outer ring texture (small dots)
                        this.ctx.fillStyle = '#B8860B';
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI * 2) / 8;
                            const dotX = centerX + Math.cos(angle) * (radius + 1);
                            const dotY = centerY + Math.sin(angle) * (radius + 1);
                            this.ctx.beginPath();
                            this.ctx.arc(dotX, dotY, 1, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // Middle ring with darker gold and inner texture
                        this.ctx.shadowBlur = 8;
                        this.ctx.beginPath();
                        this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                        this.ctx.fillStyle = '#B8860B';
                        this.ctx.fill();
                        
                        // Inner texture pattern
                        this.ctx.fillStyle = '#8B6914';
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI * 2) / 6;
                            const dotX = centerX + Math.cos(angle) * (radius * 0.8);
                            const dotY = centerY + Math.sin(angle) * (radius * 0.8);
                            this.ctx.beginPath();
                            this.ctx.arc(dotX, dotY, 1.5, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // Inner core with bright gold and gem-like center
                        this.ctx.shadowBlur = 0;
                        this.ctx.beginPath();
                        this.ctx.arc(centerX, centerY, radius * 0.7, 0, Math.PI * 2);
                        this.ctx.fillStyle = '#FFF8DC';
                        this.ctx.fill();
                        
                        // Gem-like center with facets
                        this.ctx.beginPath();
                        this.ctx.arc(centerX, centerY, radius * 0.4, 0, Math.PI * 2);
                        this.ctx.fillStyle = '#FFFFFF';
                        this.ctx.fill();
                        
                        // Center highlight
                        this.ctx.beginPath();
                        this.ctx.arc(centerX - radius * 0.1, centerY - radius * 0.1, radius * 0.15, 0, Math.PI * 2);
                        this.ctx.fillStyle = '#FFFFE0';
                        this.ctx.fill();
                        
                        // Add detailed sparkle effect with particles
                        const sparkleCount = isHovered ? 8 : 5; // More sparkles when hovered
                        for (let i = 0; i < sparkleCount; i++) {
                            const sparkleAngle = (i * Math.PI * 2) / sparkleCount;
                            const sparkleRadius = radius * (isHovered ? 0.6 : 0.4); // Larger sparkle radius when hovered
                            const sparkleX = centerX + Math.cos(sparkleAngle) * sparkleRadius;
                            const sparkleY = centerY + Math.sin(sparkleAngle) * sparkleRadius;
                            
                            // Main sparkle
                            this.ctx.beginPath();
                            this.ctx.arc(sparkleX, sparkleY, isHovered ? 3 : 2, 0, Math.PI * 2);
                            this.ctx.fillStyle = '#FFFFFF';
                            this.ctx.fill();
                            
                            // Sparkle highlight
                            this.ctx.beginPath();
                            this.ctx.arc(sparkleX - 0.5, sparkleY - 0.5, isHovered ? 1.5 : 1, 0, Math.PI * 2);
                            this.ctx.fillStyle = '#FFFFE0';
                            this.ctx.fill();
                            
                            // Sparkle border
                            this.ctx.strokeStyle = '#FFD700';
                            this.ctx.lineWidth = 0.5;
                            this.ctx.stroke();
                        }
                        
                        // Add floating gold particles around the mine
                        if (isHovered) {
                            this.ctx.fillStyle = '#FFD700';
                            this.ctx.globalAlpha = 0.6;
                            for (let i = 0; i < 6; i++) {
                                const particleAngle = (i * Math.PI * 2) / 6 + Date.now() * 0.001;
                                const particleRadius = radius * 0.8;
                                const particleX = centerX + Math.cos(particleAngle) * particleRadius;
                                const particleY = centerY + Math.sin(particleAngle) * particleRadius;
                                
                                this.ctx.beginPath();
                                this.ctx.arc(particleX, particleY, 1, 0, Math.PI * 2);
                                this.ctx.fill();
                            }
                            this.ctx.globalAlpha = 1.0;
                        }
                        
                        // Gold amount text with shadow
                        if (displaySize >= 8) {
                            this.ctx.shadowColor = '#000000';
                            this.ctx.shadowBlur = 2;
                            this.ctx.fillStyle = '#000';
                            this.ctx.font = `bold ${Math.max(8, displaySize * 0.3)}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            const amount = marker.amount ? marker.amount.toString() : '?';
                            this.ctx.fillText(amount, centerX, centerY);
                        }
                        
                        this.ctx.restore();
                        
                    } else if (marker.marker_type === 'oil') {
                        const x = marker.x * displaySize;
                        const y = marker.y * displaySize;
                        
                        // Enhanced oil platform marker - DOUBLE SIZE bubbling oil patch
                        const size = Math.max(displaySize * 1.2, 12); // Doubled from 0.6 to 1.2
                        const centerX = x + displaySize/2;
                        const centerY = y + displaySize/2;
                        
                        this.ctx.save();
                        
                        // Check if this marker is being hovered over
                        const isHovered = this.hoveredMarker && 
                            this.hoveredMarker.x === marker.x && 
                            this.hoveredMarker.y === marker.y && 
                            this.hoveredMarker.marker_type === 'oil';
                        
                        // Dark oil base with glow and texture
                        this.ctx.shadowColor = '#000080';
                        this.ctx.shadowBlur = isHovered ? 15 : 8;
                        this.ctx.fillStyle = '#000080';
                        this.ctx.fillRect(centerX - size/2, centerY - size/2, size, size);
                        
                        // Oil surface texture (ripples)
                        this.ctx.fillStyle = '#1E3A8A';
                        for (let i = 0; i < 3; i++) {
                            const rippleSize = size * (0.3 + i * 0.2);
                            this.ctx.beginPath();
                            this.ctx.arc(centerX, centerY, rippleSize, 0, Math.PI * 2);
                            this.ctx.strokeStyle = '#1E3A8A';
                            this.ctx.lineWidth = 1;
                            this.ctx.stroke();
                        }
                        
                        // Oil border with depth
                        this.ctx.shadowBlur = 0;
                        this.ctx.strokeStyle = '#4169E1';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(centerX - size/2, centerY - size/2, size, size);
                        
                        // Inner border for depth
                        this.ctx.strokeStyle = '#1E40AF';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(centerX - size/2 + 1, centerY - size/2 + 1, size - 2, size - 2);
                        
                        // Add detailed bubbling oil effect
                        const bubbleCount = isHovered ? 8 : 6; // More bubbles when hovered
                        for (let i = 0; i < bubbleCount; i++) {
                            const bubbleAngle = (i * Math.PI * 2) / bubbleCount;
                            const bubbleRadius = size * (isHovered ? 0.3 : 0.25); // Larger bubbles when hovered
                            const bubbleX = centerX + Math.cos(bubbleAngle) * bubbleRadius;
                            const bubbleY = centerY + Math.sin(bubbleAngle) * bubbleRadius;
                            
                            // Main bubble
                            this.ctx.beginPath();
                            this.ctx.arc(bubbleX, bubbleY, isHovered ? 2.5 : 2, 0, Math.PI * 2);
                            this.ctx.fillStyle = '#1E90FF';
                            this.ctx.fill();
                            
                            // Bubble highlight
                            this.ctx.beginPath();
                            this.ctx.arc(bubbleX - 0.5, bubbleY - 0.5, isHovered ? 1 : 0.8, 0, Math.PI * 2);
                            this.ctx.fillStyle = '#87CEEB';
                            this.ctx.fill();
                            
                            // Bubble border
                            this.ctx.strokeStyle = '#000080';
                            this.ctx.lineWidth = 0.5;
                            this.ctx.stroke();
                        }
                        
                        // Add oil surface reflections
                        this.ctx.fillStyle = '#1E90FF';
                        this.ctx.globalAlpha = 0.3;
                        for (let i = 0; i < 4; i++) {
                            const reflectionX = centerX + (Math.random() - 0.5) * size * 0.6;
                            const reflectionY = centerY + (Math.random() - 0.5) * size * 0.6;
                            this.ctx.beginPath();
                            this.ctx.arc(reflectionX, reflectionY, 1, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        this.ctx.globalAlpha = 1.0;
                        
                        // Oil amount text
                        if (displaySize >= 8) {
                            this.ctx.fillStyle = '#FFF';
                            this.ctx.font = `bold ${Math.max(8, displaySize * 0.3)}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            const amount = marker.amount ? marker.amount.toString() : '?';
                            this.ctx.fillText(amount, centerX, centerY);
                        }
                        
                        this.ctx.restore();
                    }
                }
            }

            renderUnits(displaySize) {
                // Unit rendering logic
            }

            renderPlayers(displaySize) {
                console.log('🎨 renderPlayers called, markers:', currentMapData.markers);
                if (!currentMapData.markers) {
                    console.log('🎨 No markers found in currentMapData');
                    return;
                }
                
                console.log(`🎨 Found ${currentMapData.markers.length} markers to render`);
                for (const marker of currentMapData.markers) {
                    console.log('🎨 Processing marker:', marker);
                    if (marker.marker_type === 'player') {
                        const x = marker.x * displaySize;
                        const y = marker.y * displaySize;
                        console.log(`🎨 Rendering player marker at pixel position (${x}, ${y}) from tile position (${marker.x}, ${marker.y}) with displaySize ${displaySize}`);
                        
                        // Player starting position marker - DOUBLE SIZE and much more detailed
                        const size = Math.max(displaySize * 5, 60); // Doubled from 2.5 to 5
                        
                        // Player color (different colors for different players)
                        const playerColors = [
                            '#FF0000', // Red
                            '#0000FF', // Blue  
                            '#00FF00', // Green
                            '#FFFF00', // Yellow
                            '#FF00FF', // Magenta
                            '#00FFFF', // Cyan
                            '#FFA500', // Orange
                            '#800080'  // Purple
                        ];
                        
                        const playerColor = playerColors[marker.player % playerColors.length];
                        
                        // Calculate center position
                        const centerX = x + displaySize/2;
                        const centerY = y + displaySize/2;
                        
                        // Draw chess piece style marker
                        this.ctx.save();
                        
                        // Check if this marker is being hovered over
                        const isHovered = this.hoveredMarker && 
                            this.hoveredMarker.x === marker.x && 
                            this.hoveredMarker.y === marker.y && 
                            this.hoveredMarker.marker_type === 'player';
                        
                        // Add subtle glow effect
                        this.ctx.shadowColor = playerColor;
                        this.ctx.shadowBlur = isHovered ? 20 : 8;
                        
                        // Apply animation scaling if this marker is animating
                        if (marker.isAnimating && marker.animationScale) {
                            this.ctx.save();
                            this.ctx.translate(centerX, centerY);
                            this.ctx.scale(marker.animationScale, marker.animationScale);
                            this.ctx.translate(-centerX, -centerY);
                        }
                        
                        // Draw detailed 3D chess piece base (pedestal) with enhanced detail
                        this.ctx.beginPath();
                        // Main base rectangle with rounded corners effect
                        this.ctx.rect(centerX - size/3, centerY + size/3, size * 2/3, size/6);
                        this.ctx.fillStyle = '#8B4513'; // Brown base
                        this.ctx.fill();
                        
                        // Base shadow/highlight for 3D effect
                        this.ctx.beginPath();
                        this.ctx.rect(centerX - size/3 + 2, centerY + size/3 + 1, size * 2/3 - 4, size/6 - 2);
                        this.ctx.fillStyle = '#A0522D'; // Lighter brown highlight
                        this.ctx.fill();
                        
                        // Base border with depth
                        this.ctx.strokeStyle = '#654321';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                        
                        // Add base texture (wood grain effect)
                        this.ctx.strokeStyle = '#654321';
                        this.ctx.lineWidth = 1;
                        for (let i = 0; i < 3; i++) {
                            const lineY = centerY + size/3 + 2 + i * 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(centerX - size/3 + 4, lineY);
                            this.ctx.lineTo(centerX + size/3 - 4, lineY);
                            this.ctx.stroke();
                        }
                        
                        // Draw detailed chess piece body (tiered design)
                        // Bottom tier (wider)
                        this.ctx.beginPath();
                        this.ctx.ellipse(centerX, centerY + size/6, size/2.2, size/3, 0, 0, Math.PI * 2);
                        this.ctx.fillStyle = playerColor;
                        this.ctx.fill();
                        
                        // Middle tier
                        this.ctx.beginPath();
                        this.ctx.ellipse(centerX, centerY - size/8, size/1.8, size/2.5, 0, 0, Math.PI * 2);
                        this.ctx.fillStyle = this.lightenColor(playerColor, 0.2);
                        this.ctx.fill();
                        
                        // Top tier (narrower)
                        this.ctx.beginPath();
                        this.ctx.ellipse(centerX, centerY - size/3, size/1.4, size/2, 0, 0, Math.PI * 2);
                        this.ctx.fillStyle = this.lightenColor(playerColor, 0.4);
                        this.ctx.fill();
                        
                        // Body borders with depth
                        this.ctx.strokeStyle = '#000000';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                        
                        // Draw detailed crown with jewels and enhanced detail
                        this.ctx.beginPath();
                        this.ctx.arc(centerX, centerY - size/3, size/4, 0, 2 * Math.PI);
                        this.ctx.fillStyle = isHovered ? '#FFFF00' : '#FFD700'; // Brighter crown when hovered
                        this.ctx.fill();
                        this.ctx.strokeStyle = '#B8860B';
                        this.ctx.lineWidth = isHovered ? 2 : 1; // Thicker border when hovered
                        this.ctx.stroke();
                        
                        // Add extra glow effect when hovered
                        if (isHovered) {
                            this.ctx.beginPath();
                            this.ctx.arc(centerX, centerY - size/3, size/4 + 2, 0, 2 * Math.PI);
                            this.ctx.strokeStyle = '#FFD700';
                            this.ctx.lineWidth = 1;
                            this.ctx.stroke();
                        }
                        
                        // Reset shadow for text
                        this.ctx.shadowBlur = 0;
                        
                        // Draw player number on the body
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = `bold ${Math.max(size * 0.3, 14)}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText((marker.player + 1).toString(), centerX, centerY);
                        
                        // Add race indicator (small icon)
                        const raceIcon = marker.race === 'Human' ? '⚔️' : '🛡️';
                        this.ctx.font = `${Math.max(size * 0.2, 10)}px Arial`;
                        this.ctx.fillText(raceIcon, centerX, centerY + size/3);
                        
                        // Restore animation transformations
                        if (marker.isAnimating && marker.animationScale) {
                            this.ctx.restore();
                        }
                        
                        this.ctx.restore();
                    }
                }
            }

            handleMouseMove(event) {
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                const displaySize = this.tileSize * this.zoomLevel;
                
                const tileX = Math.floor(x / displaySize);
                const tileY = Math.floor(y / displaySize);
                
                // Scale coordinates to internal canvas resolution for marker detection
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const canvasX = x * scaleX;
                const canvasY = y * scaleY;
                
                // Pass scaled canvas coordinates for marker detection, client coordinates for tooltip positioning
                this.showTileTooltip(tileX, tileY, canvasX, canvasY, event.clientX, event.clientY);
            }

            showTileTooltip(tileX, tileY, canvasX, canvasY, clientX, clientY) {
                if (!currentMapData) return;
                
                const tooltip = document.getElementById('tooltip');
                
                // Check for markers at this position with better detection
                // First try exact match, then check if we're within the marker's rendered area
                let marker = currentMapData.markers ? currentMapData.markers.find(m => 
                    m.x === tileX && m.y === tileY
                ) : null;
                
                // If no exact match, check if we're hovering over a marker's rendered area
                if (!marker && currentMapData.markers) {
                    const displaySize = this.tileSize * this.zoomLevel;
                    console.log(`🔍 Tooltip: Checking pixel-based marker detection. Canvas: (${canvasX}, ${canvasY}), DisplaySize: ${displaySize}`);
                    
                    marker = currentMapData.markers.find(m => {
                        // Calculate the actual rendered bounds for this marker type
                        const markerBounds = this.getMarkerRenderBounds(m, displaySize);
                        
                        const isWithinBounds = (canvasX >= markerBounds.x && canvasX <= markerBounds.x + markerBounds.width &&
                                              canvasY >= markerBounds.y && canvasY <= markerBounds.y + markerBounds.height);
                        
                        // Debug: Show what we're checking
                        console.log(`🔍 Checking marker ${m.marker_type} at tile (${m.x}, ${m.y}) → bounds: x=${markerBounds.x}, y=${markerBounds.y}, w=${markerBounds.width}, h=${markerBounds.height}`);
                        console.log(`🔍 Mouse at canvas (${canvasX}, ${canvasY}) - Within bounds: ${isWithinBounds}`);
                        
                        if (isWithinBounds) {
                            console.log(`🎯 Tooltip: Found marker via pixel detection:`, m);
                        }
                        
                        // Check if mouse is within the marker's rendered bounds
                        return isWithinBounds;
                    });
                }
                
                // If we have a marker, prioritize showing marker information
                if (marker) {
                    console.log(`🎯 Tooltip: Found marker at (${tileX}, ${tileY}):`, marker);
                    
                    let markerIcon = '';
                    let markerColor = '';
                    
                    // Set appropriate icon and color based on marker type
                    if (marker.marker_type === 'player') {
                        markerIcon = '👤';
                        markerColor = marker.race === 'Human' ? '#FF6B6B' : '#4ECDC4';
                    } else if (marker.marker_type === 'goldmine') {
                        markerIcon = '💰';
                        markerColor = '#FFD700';
                    } else if (marker.marker_type === 'oil') {
                        markerIcon = '🛢️';
                        markerColor = '#000080';
                    }
                    
                    tooltip.innerHTML = `
                        <div class="tooltip-header" style="color: ${markerColor}">${markerIcon} ${marker.marker_type.toUpperCase()}</div>
                        <div class="tooltip-content">
                            <strong>Position:</strong> (${tileX}, ${tileY})<br>
                            <strong>Label:</strong> ${marker.label}<br>
                            ${marker.description ? `<strong>Description:</strong> ${marker.description}<br>` : ''}
                            ${marker.amount ? `<strong>Gold Amount:</strong> <span style="color: #FFD700; font-weight: bold;">${marker.amount.toLocaleString()}</span><br>` : ''}
                            ${marker.race ? `<strong>Race:</strong> <span style="color: ${marker.race === 'Human' ? '#FF6B6B' : '#4ECDC4'}; font-weight: bold;">${marker.race}</span><br>` : ''}
                            ${marker.player !== undefined ? `<strong>Player Number:</strong> <span style="color: #FFD700; font-weight: bold;">${marker.player + 1}</span><br>` : ''}
                            ${marker.marker_type === 'player' ? `<strong>Starting Resources:</strong> 1000 Gold, 500 Lumber, 200 Oil<br>` : ''}
                            ${marker.marker_type === 'goldmine' ? `<strong>Mine Type:</strong> Neutral Goldmine<br>` : ''}
                            <br>
                            <div style="font-size: 0.9em; opacity: 0.8; border-top: 1px solid #444; padding-top: 8px;">
                                <strong>Tile Info:</strong><br>
                                <strong>Terrain:</strong> ${this.textureManager.getTerrainType(currentMapData.terrain ? currentMapData.terrain[tileY * currentMapData.width + tileX] : 0, currentMapData.tileset)}<br>
                                <strong>Tileset:</strong> ${this.getTilesetName(currentMapData.tileset)}
                            </div>
                        </div>
                    `;
                } else {
                    // No marker, show regular tile information
                    console.log(`🔍 Tooltip: No marker found at (${tileX}, ${tileY}), showing tile info`);
                    const tileIndex = tileY * currentMapData.width + tileX;
                    const tileId = currentMapData.terrain ? currentMapData.terrain[tileIndex] : 'N/A';
                    const terrainType = this.textureManager.getTerrainType(tileId, currentMapData.tileset);
                    
                    tooltip.innerHTML = `
                        <div class="tooltip-header">🔍 Tile Information</div>
                        <div class="tooltip-content">
                            <strong>Position:</strong> (${tileX}, ${tileY})<br>
                            <strong>Tile ID:</strong> ${tileId} (${tileId !== 'N/A' ? '0x' + parseInt(tileId).toString(16).toUpperCase() : 'N/A'})<br>
                            <strong>Tileset:</strong> ${currentMapData.tileset} (${this.getTilesetName(currentMapData.tileset)})<br>
                            <strong>Terrain:</strong> ${terrainType}<br>
                            <strong>Color:</strong> <span style="color: ${this.textureManager.getFallbackColorForTerrainType(terrainType)}">${this.textureManager.getFallbackColorForTerrainType(terrainType)}</span><br>
                            <strong>Range:</strong> ${this.getTileRange(tileId)}
                        </div>
                    `;
                }
                
                // Position tooltip closer to cursor and ensure it stays within viewport
                const tooltipWidth = 320;
                const tooltipHeight = marker ? 280 : 140; // Larger for markers
                
                // Add hover effect to the marker if we found one
                if (marker) {
                    this.addMarkerHoverEffect(marker);
                }
                const padding = 10;
                
                let left = clientX + 15;
                let top = clientY + 15;
                
                // Adjust if tooltip would go off the right edge
                if (left + tooltipWidth > window.innerWidth) {
                    left = clientX - tooltipWidth - 15;
                }
                
                // Adjust if tooltip would go off the bottom edge
                if (top + tooltipHeight > window.innerHeight) {
                    top = clientY - tooltipHeight - 15;
                }
                
                // Ensure tooltip doesn't go off the left or top edges
                left = Math.max(padding, left);
                top = Math.max(padding, top);
                
                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
                tooltip.style.display = 'block';
                
                // Add animation class after a brief delay
                setTimeout(() => {
                    tooltip.classList.add('show');
                }, 10);
            }

            hideTooltip() {
                const tooltip = document.getElementById('tooltip');
                tooltip.classList.remove('show');
                tooltip.style.display = 'none';
                
                // Remove hover effects from all markers
                this.removeMarkerHoverEffects();
            }
            
            addMarkerHoverEffect(marker) {
                // Store the hovered marker for rendering enhancement
                this.hoveredMarker = marker;
                
                // Add animation properties
                marker.animationStartTime = Date.now();
                marker.isAnimating = true;
                
                // Start animation loop for this marker
                this.startMarkerAnimation(marker);
                
                // Trigger a redraw to show enhanced effects
                this.redraw();
            }
            
            startMarkerAnimation(marker) {
                if (!marker.isAnimating) return;
                
                const elapsed = Date.now() - marker.animationStartTime;
                const animationDuration = 2000; // 2 seconds
                const progress = (elapsed % animationDuration) / animationDuration;
                
                // Update animation properties
                marker.animationProgress = progress;
                marker.animationAngle = progress * Math.PI * 2;
                marker.animationScale = 1 + Math.sin(progress * Math.PI * 4) * 0.1;
                
                // Continue animation
                requestAnimationFrame(() => this.startMarkerAnimation(marker));
                
                // Trigger redraw for smooth animation
                this.redraw();
            }
            
            removeMarkerHoverEffects() {
                // Stop all marker animations
                if (currentMapData && currentMapData.markers) {
                    currentMapData.markers.forEach(marker => {
                        marker.isAnimating = false;
                        marker.animationProgress = 0;
                        marker.animationScale = 1;
                    });
                }
                
                // Clear the hovered marker
                this.hoveredMarker = null;
                
                // Trigger a redraw to remove enhanced effects
                this.redraw();
            }
            
            // Helper function to lighten colors for 3D effects
            lightenColor(color, factor) {
                // Convert hex to RGB
                const hex = color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                
                // Lighten by factor
                const newR = Math.min(255, Math.round(r + (255 - r) * factor));
                const newG = Math.min(255, Math.round(g + (255 - g) * factor));
                const newB = Math.min(255, Math.round(b + (255 - b) * factor));
                
                // Convert back to hex
                return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
            }

            /**
             * Calculate the actual rendered bounds for a marker based on its type and display size
             */
            getMarkerRenderBounds(marker, displaySize) {
                const baseX = marker.x * displaySize;
                const baseY = marker.y * displaySize;
                
                if (marker.marker_type === 'player') {
                    // Player markers are rendered with size = displaySize * 2.5
                    const size = Math.max(displaySize * 2.5, 30);
                    // The white background circle has radius = size/2 + 2
                    const backgroundRadius = size/2 + 2;
                    // The actual rendered area includes the background circle
                    const actualSize = backgroundRadius * 2;
                    
                    return {
                        x: baseX + displaySize/2 - backgroundRadius,
                        y: baseY + displaySize/2 - backgroundRadius,
                        width: actualSize,
                        height: actualSize
                    };
                } else if (marker.marker_type === 'goldmine') {
                    // Goldmine markers have radius = displaySize * 0.4
                    const radius = Math.max(displaySize * 0.4, 4);
                    const actualSize = radius * 2;
                    
                    return {
                        x: baseX + displaySize/2 - radius,
                        y: baseY + displaySize/2 - radius,
                        width: actualSize,
                        height: actualSize
                    };
                } else if (marker.marker_type === 'oil') {
                    // Oil markers have size = displaySize * 0.6
                    const size = Math.max(displaySize * 0.6, 6);
                    
                    return {
                        x: baseX + displaySize/2 - size/2,
                        y: baseY + displaySize/2 - size/2,
                        width: size,
                        height: size
                    };
                } else {
                    // Default fallback - use tile size
                    return {
                        x: baseX,
                        y: baseY,
                        width: displaySize,
                        height: displaySize
                    };
                }
            }

            /**
             * Get tileset name from ID (based on war2tools specifications)
             */
            getTilesetName(tilesetId) {
                const tilesets = {
                    0: 'Forest',
                    1: 'Winter', 
                    2: 'Wasteland',
                    3: 'Swamp'
                };
                return tilesets[tilesetId] || 'Unknown';
            }

            /**
             * Get tile range description (based on war2tools tile mapping)
             */
            getTileRange(tileId) {
                if (tileId === 'N/A') return 'Unknown';
                
                if (tileId >= 0 && tileId <= 15) return 'Basic Grass (0x00-0x0F)';
                if (tileId >= 16 && tileId <= 47) return 'Water (0x10-0x2F)';
                if (tileId >= 48 && tileId <= 79) return 'Coast (0x30-0x4F)';
                if (tileId >= 80 && tileId <= 95) return 'Ground Variations (0x50-0x5F)';
                if (tileId >= 96 && tileId <= 111) return 'Rock/Mountain (0x60-0x6F)';
                if (tileId >= 112 && tileId <= 127) return 'Forest/Trees (0x70-0x7F)';
                if (tileId >= 128) return 'Extended Variations (0x80+)';
                
                return 'Unknown Range';
            }
        }

        // Event Listeners
        function setupEventListeners() {
            // File input
            document.getElementById('mapFile').addEventListener('change', handleFileSelect);
            
            // Rendering mode buttons
            document.getElementById('textureMode').addEventListener('click', () => setRenderingMode('texture'));
            document.getElementById('colorMode').addEventListener('click', () => setRenderingMode('color'));
            document.getElementById('hybridMode').addEventListener('click', () => setRenderingMode('hybrid'));
            
            // System buttons
            document.getElementById('extractTextures').addEventListener('click', extractTextures);
            document.getElementById('clearCache').addEventListener('click', clearCache);
            
            // Zoom slider
            document.getElementById('zoomSlider').addEventListener('input', (e) => {
                const zoom = parseInt(e.target.value);
                document.getElementById('zoomValue').textContent = zoom + 'x';
                if (mapRenderer) mapRenderer.setZoom(zoom);
            });
            
            // Overlay toggles
            document.getElementById('showResources').addEventListener('change', (e) => {
                if (mapRenderer) mapRenderer.setOverlays({ resources: e.target.checked });
            });
            
            document.getElementById('showUnits').addEventListener('change', (e) => {
                if (mapRenderer) mapRenderer.setOverlays({ units: e.target.checked });
            });
            
            document.getElementById('showPlayers').addEventListener('change', (e) => {
                if (mapRenderer) mapRenderer.setOverlays({ players: e.target.checked });
            });
            
            // Tileset preview
            document.getElementById('previewTileset').addEventListener('click', previewSelectedTileset);
        }

        // File handling
        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                showStatus('Loading map file...', 'loading');
                
                // Read the PUD file
                const arrayBuffer = await file.arrayBuffer();
                const fileData = new Uint8Array(arrayBuffer);
                
                // Parse PUD file using JavaScript parser
                console.log('🔧 Creating FixedBinaryParser instance...');
                const binaryParser = new FixedBinaryParser(); // Use the fixed parser
                console.log('✅ FixedBinaryParser instance created:', binaryParser);
                
                console.log('🔧 Starting PUD file parsing...');
                const mapData = binaryParser.parsePudFile(fileData);
                console.log('✅ PUD file parsing completed');
                
                console.log('Parsed map data:', mapData);
                                 console.log('Map dimensions:', mapData.width, 'x', mapData.height);
                 console.log('Terrain runs:', mapData.terrain_runs?.length || 0);
                 console.log('Markers:', mapData.markers?.length || 0);
                 console.log('Tileset:', mapData.tileset);
                 
                 // Debug: Show all markers found
                 if (mapData.markers && mapData.markers.length > 0) {
                     console.log('🔍 All markers found:');
                     mapData.markers.forEach((marker, index) => {
                         console.log(`  ${index + 1}. ${marker.marker_type} at (${marker.x}, ${marker.y}) - ${marker.label}`);
                     });
                 } else {
                     console.log('⚠️ No markers found in map');
                 }
                
                // Render the map
                await mapRenderer.renderMap(mapData);
                
                // Update map information display
                updateMapInfo(mapData);
                
                // Show tileset information
                const tilesetName = textureManager.getTilesetName(mapData.tileset);
                showStatus(`Map loaded successfully! Tileset: ${tilesetName}`, 'success');
                
                // Log tileset details
                console.log(`🎨 Map tileset: ${mapData.tileset} (${tilesetName})`);
                console.log(`🎨 Terrain classification will use ${tilesetName} color scheme`);
                
            } catch (error) {
                console.error('❌ Failed to load map:', error);
                showStatus('Failed to load map: ' + error.message, 'error');
            }
        }

        // Rendering mode functions
        function setRenderingMode(mode) {
            console.log(`🎨 Setting rendering mode to: ${mode}`);
            // Implementation would switch between texture, color, and hybrid modes
        }

        // Texture extraction
        async function extractTextures() {
            try {
                showStatus('Extracting textures...', 'loading');
                
                if (textureManager) {
                    await textureManager.initializeWithoutWasm();
                    updateTextureStats();
                    showStatus('Color-based textures ready!', 'success');
                }
                
            } catch (error) {
                console.error('❌ Texture extraction failed:', error);
                showStatus('Texture extraction failed: ' + error.message, 'error');
            }
        }

        // Cache management
        function clearCache() {
            if (textureManager) {
                textureManager.clearCache();
                updateTextureStats();
                showStatus('Cache cleared!', 'success');
            }
        }

        // Utility functions
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function updateTextureStats() {
            if (textureManager) {
                const stats = textureManager.getStats();
                document.getElementById('textureStatus').textContent = stats.isLoaded ? '✅' : '❌';
                document.getElementById('cachedTextures').textContent = stats.cachedTextures;
                document.getElementById('totalTextures').textContent = stats.totalTextures;
                document.getElementById('totalSize').textContent = Math.round(stats.totalSize / 1024) + ' KB';
            }
        }

        function updateMapInfo(mapData) {
            if (mapData) {
                const tilesetName = textureManager.getTilesetName(mapData.tileset);
                document.getElementById('mapTileset').textContent = tilesetName;
                document.getElementById('mapDimensions').textContent = `${mapData.width}×${mapData.height}`;
                document.getElementById('mapMarkers').textContent = mapData.markers?.length || 0;
                document.getElementById('mapTerrain').textContent = mapData.terrain_runs?.length || 0;
                
                // Update tileset selector to show current tileset
                document.getElementById('tilesetSelector').value = mapData.tileset;
            }
        }

        function previewSelectedTileset() {
            if (!currentMapData) {
                showStatus('No map loaded! Load a map first.', 'error');
                return;
            }
            
            const selectedTileset = parseInt(document.getElementById('tilesetSelector').value);
            const tilesetName = textureManager.getTilesetName(selectedTileset);
            
            // Create a copy of the map data with the selected tileset
            const previewMapData = {
                ...currentMapData,
                tileset: selectedTileset
            };
            
            // Re-render the map with the new tileset
            mapRenderer.renderMap(previewMapData);
            
            // Update the display
            updateMapInfo(previewMapData);
            
            showStatus(`Previewing ${tilesetName} tileset!`, 'success');
            console.log(`🎨 Previewing ${tilesetName} tileset (${selectedTileset})`);
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
