// Prevents additional console window on Windows in release`n#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]`n`nuse serde::{Deserialize, Serialize};`nuse std::collections::HashMap;`nuse anyhow::Result;`n`n#[derive(Debug, Serialize, Deserialize)]`nstruct GameInfo {`n    name: String,`n    path: String,`n    version: String,`n    is_running: bool,`n    process_id: Option<u32>,`n}`n`n#[derive(Debug, Serialize, Deserialize)]`nstruct ScanResult {`n    found: bool,`n    path: String,`n    multiple_installations: bool,`n    all_paths: Vec<String>,`n}`n`n#[tauri::command]`nasync fn scan_for_games() -> Result<HashMap<String, ScanResult>, String> {`n    // TODO: Implement actual game scanning logic`n    let mut results = HashMap::new();`n    `n    // Mock results for now`n    results.insert("wc2-remastered".to_string(), ScanResult {`n        found: true,`n        path: "C:\\Program Files\\Warcraft II Remastered".to_string(),`n        multiple_installations: false,`n        all_paths: vec!["C:\\Program Files\\Warcraft II Remastered".to_string()],`n    });`n    `n    Ok(results)`n}`n`n#[tauri::command]`nasync fn get_running_games() -> Result<Vec<GameInfo>, String> {`n    // TODO: Implement actual process detection`n    Ok(vec![])`n}`n`n#[tauri::command]`nasync fn launch_game(game_name: String) -> Result<(), String> {`n    // TODO: Implement game launching`n    println!("Launching game: {}", game_name);`n    Ok(())`n}`n`nfn main() {`n    tauri::Builder::default()`n        .invoke_handler(tauri::generate_handler![`n            scan_for_games,`n            get_running_games,`n            launch_game`n        ])`n        .run(tauri::generate_context!())`n        .expect("error while running tauri application");`n}
